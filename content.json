{"meta":{"title":"VanillaYiYi","subtitle":"","description":"希望在这里分享我的经验与生活！","author":"VanillaYiYi","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2022-07-28T16:12:57.000Z","updated":"2024-09-03T07:42:24.949Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":"#l_main { width: calc(100% - 1 * 0px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_side { display: none; } #post-body { display:flex; flex-wrap: wrap; } #post-body p { width: 48%; margin: 5px; }"},{"title":"所有标签","date":"2022-07-28T16:12:51.000Z","updated":"2024-09-03T07:42:24.949Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":"#l_main { width: calc(100% - 1 * 0px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_side { display: none; } #post-body { display:flex; flex-wrap: wrap; } #post-body p { width: 48%; margin: 5px; }"},{"title":"about","date":"2022-07-28T16:13:07.000Z","updated":"2024-09-03T07:42:24.949Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"#l_main { width: calc(100% - 1 * 0px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_side { display: none; } #post-body { display:flex; flex-wrap: wrap; } #post-body p { width: 48%; margin: 5px; }"},{"title":"留言板","date":"2022-07-28T16:13:33.000Z","updated":"2024-09-03T07:42:24.949Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"欢迎在下方留言！ 这里可以写下你的想法和建议，以待后续改进。 #l_main { width: calc(100% - 1 * 0px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_side { display: none; } #post-body { display:flex; flex-wrap: wrap; } #post-body p { width: 48%; margin: 5px; }"},{"title":"相册","date":"2022-10-05T12:43:18.000Z","updated":"2024-09-04T08:33:54.239Z","comments":false,"path":"gallery/index.html","permalink":"http://example.com/gallery/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; max-width: 840px; margin: auto; } #bottom { display: none; } #post-body { display:flex; flex-wrap: wrap; } #post-body p { /* width: 48%; */ margin: 5px; } .article center, .article center p { text-align: center; margin-bottom: 50px; margin-top: -30px; } #post-body p { /* display:flex; */ flex-wrap: wrap; } #post-body p img { width: 32%; margin: 5px; } 今日写真101 理想生活 放学别走 夜景浪漫氛围感 生活里被藏起来的温柔 你比温柔更浪漫 顺其自然 角色妹妹 闺蜜钟恩琪生日照 爱你的人会用不同的方式爱你 风华绝代 温柔奶fufu 爱不平庸 生活如此多娇 知性之美 花 情不自禁 优雅 暗调私房"},{"title":"今日写真","date":"2024-09-04T08:33:54.239Z","updated":"2024-09-04T08:33:54.239Z","comments":false,"path":"gallery/今日写真/index.html","permalink":"http://example.com/gallery/%E4%BB%8A%E6%97%A5%E5%86%99%E7%9C%9F/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 24px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #bottom { display: none; } #post-body { display:flex; flex-wrap: wrap; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 32%; margin: 5px; }"},{"title":"8.23优雅","date":"2024-09-04T08:33:54.239Z","updated":"2024-09-04T08:33:54.239Z","comments":false,"path":"gallery/晚晚晚儿呀/优雅/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E4%BC%98%E9%9B%85/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 48%; margin: 5px; }"},{"title":"7.17你比温柔更浪漫","date":"2024-09-04T08:33:54.239Z","updated":"2024-09-04T08:33:54.239Z","comments":false,"path":"gallery/晚晚晚儿呀/你比温柔更浪漫/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E4%BD%A0%E6%AF%94%E6%B8%A9%E6%9F%94%E6%9B%B4%E6%B5%AA%E6%BC%AB/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 32%; margin: 5px; }"},{"title":"9.7夜景浪漫氛围感","date":"2024-09-04T08:33:54.239Z","updated":"2024-09-04T08:33:54.239Z","comments":false,"path":"gallery/晚晚晚儿呀/夜景浪漫氛围感/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E5%A4%9C%E6%99%AF%E6%B5%AA%E6%BC%AB%E6%B0%9B%E5%9B%B4%E6%84%9F/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 48%; margin: 5px; }"},{"title":"8.5情不自禁","date":"2024-09-04T08:33:54.239Z","updated":"2024-09-04T08:33:54.239Z","comments":false,"path":"gallery/晚晚晚儿呀/情不自禁/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E6%83%85%E4%B8%8D%E8%87%AA%E7%A6%81/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 32%; margin: 5px; }"},{"title":"8.16放学别走","date":"2024-09-04T08:33:54.239Z","updated":"2024-09-04T08:33:54.239Z","comments":false,"path":"gallery/晚晚晚儿呀/放学别走/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E6%94%BE%E5%AD%A6%E5%88%AB%E8%B5%B0/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 48%; margin: 5px; }"},{"title":"8.23暗调私房","date":"2024-09-04T08:33:54.240Z","updated":"2024-09-04T08:33:54.240Z","comments":false,"path":"gallery/晚晚晚儿呀/暗调私房/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E6%9A%97%E8%B0%83%E7%A7%81%E6%88%BF/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 32%; margin: 5px; }"},{"title":"浪漫温柔无数","date":"2024-09-04T08:33:54.240Z","updated":"2024-09-04T08:33:54.240Z","comments":false,"path":"gallery/晚晚晚儿呀/浪漫温柔无数/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E6%B5%AA%E6%BC%AB%E6%B8%A9%E6%9F%94%E6%97%A0%E6%95%B0/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 32%; margin: 5px; }"},{"title":"12.11温柔奶fufu","date":"2024-09-04T08:33:54.240Z","updated":"2024-09-04T08:33:54.240Z","comments":false,"path":"gallery/晚晚晚儿呀/温柔奶fufu/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E6%B8%A9%E6%9F%94%E5%A5%B6fufu/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 32%; margin: 5px; }"},{"title":"7.28爱不平庸","date":"2024-09-04T08:33:54.240Z","updated":"2024-09-04T08:33:54.240Z","comments":false,"path":"gallery/晚晚晚儿呀/爱不平庸/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E7%88%B1%E4%B8%8D%E5%B9%B3%E5%BA%B8/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 48%; margin: 5px; }"},{"title":"8.1生活如此多娇","date":"2024-09-04T08:33:54.240Z","updated":"2024-09-04T08:33:54.240Z","comments":false,"path":"gallery/晚晚晚儿呀/生活如此多娇/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E7%94%9F%E6%B4%BB%E5%A6%82%E6%AD%A4%E5%A4%9A%E5%A8%87/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { /* 一行两个 width: 48%; */ /* 一行三个 width: 32%; */ width: 32%; margin: 5px; }"},{"title":"8.6爱你的人会用不同的方式爱你","date":"2024-09-04T08:33:54.240Z","updated":"2024-09-04T08:33:54.240Z","comments":false,"path":"gallery/晚晚晚儿呀/爱你的人会用不同的方式爱你/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E7%88%B1%E4%BD%A0%E7%9A%84%E4%BA%BA%E4%BC%9A%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E5%BC%8F%E7%88%B1%E4%BD%A0/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 32%; margin: 5px; }"},{"title":"1.13生活里被藏起来的温柔","date":"2024-09-04T08:33:54.240Z","updated":"2024-09-04T08:33:54.240Z","comments":false,"path":"gallery/晚晚晚儿呀/生活里被藏起来的温柔/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E7%94%9F%E6%B4%BB%E9%87%8C%E8%A2%AB%E8%97%8F%E8%B5%B7%E6%9D%A5%E7%9A%84%E6%B8%A9%E6%9F%94/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 32%; margin: 5px; }"},{"title":"8.12理想生活","date":"2024-09-04T08:33:54.240Z","updated":"2024-09-04T08:33:54.240Z","comments":false,"path":"gallery/晚晚晚儿呀/理想生活/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E7%90%86%E6%83%B3%E7%94%9F%E6%B4%BB/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 48%; margin: 5px; }"},{"title":"8.21知性之美","date":"2024-09-04T08:33:54.241Z","updated":"2024-09-04T08:33:54.241Z","comments":false,"path":"gallery/晚晚晚儿呀/知性之美/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E7%9F%A5%E6%80%A7%E4%B9%8B%E7%BE%8E/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 48%; margin: 5px; }"},{"title":"11.20绝色妹妹","date":"2024-09-04T08:33:54.241Z","updated":"2024-09-04T08:33:54.241Z","comments":false,"path":"gallery/晚晚晚儿呀/绝妹/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E7%BB%9D%E5%A6%B9/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 48%; margin: 5px; }"},{"title":"7.26花","date":"2024-09-04T08:33:54.241Z","updated":"2024-09-04T08:33:54.241Z","comments":false,"path":"gallery/晚晚晚儿呀/花/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E8%8A%B1/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 32%; margin: 5px; }"},{"title":"7.17闺蜜钟恩琪生日照","date":"2024-09-04T08:33:54.241Z","updated":"2024-09-04T08:33:54.241Z","comments":false,"path":"gallery/晚晚晚儿呀/闺蜜钟恩琪生日照/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E9%97%BA%E8%9C%9C%E9%92%9F%E6%81%A9%E7%90%AA%E7%94%9F%E6%97%A5%E7%85%A7/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 32%; margin: 5px; }"},{"title":"8.14顺其自然","date":"2024-09-04T08:33:54.241Z","updated":"2024-09-04T08:33:54.241Z","comments":false,"path":"gallery/晚晚晚儿呀/顺其自然/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E9%A1%BA%E5%85%B6%E8%87%AA%E7%84%B6/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 48%; margin: 5px; }"},{"title":"8.18风华绝代","date":"2024-09-04T08:33:54.241Z","updated":"2024-09-04T08:33:54.241Z","comments":false,"path":"gallery/晚晚晚儿呀/风华绝代/index.html","permalink":"http://example.com/gallery/%E6%99%9A%E6%99%9A%E6%99%9A%E5%84%BF%E5%91%80/%E9%A3%8E%E5%8D%8E%E7%BB%9D%E4%BB%A3/index.html","excerpt":"","text":"#l_main { max-width: calc(100% - 1 * 240px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_main.no_sidebar { width: 100%; padding-right: 0; margin: auto; } #bottom { display: none; } #post-body p { display:flex; flex-wrap: wrap; } #post-body p img { width: 48%; margin: 5px; }"}],"posts":[{"title":"站外神器linktree使用教程","slug":"站外神器linktree使用教程","date":"2024-09-04T08:58:47.000Z","updated":"2024-09-04T08:58:47.000Z","comments":true,"path":"2024/09/04/站外神器linktree使用教程/","link":"","permalink":"http://example.com/2024/09/04/%E7%AB%99%E5%A4%96%E7%A5%9E%E5%99%A8linktree%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"这篇文章会完全刷新你对TikTok如何导流多个网站的认知，全文干货，无废话！ 如果你是一个TikTok小白，知道TikTok是一个风口，但不知道怎么玩，对于TikTok如何导流多个网站完全不得要领。在网上搜寻了很多长篇大论的资料，但有价值的极少，看完还是云里雾里。 不要怕，你只是没有找对入门的方法！ TikTok个人主页的website可以导流到很多平台，限制非常少。 但通常这里只能放一个网址。所以，很多TikTok创作者会选择使用Linktree制作一个多链接的汇合页面，由粉丝自由选择跳转的地方。 今天就和大家分享，如何用linktree制作跳转页！ 一、注册Linktree点击链接 https://linktr.ee/register 进入官网进行注册，依次填写下面的信息： Email：电子邮箱 Username：账号名称 Password：密码 这里需要注意的是，Username会成为你Linktree的网址后缀。 举个例子，我在Username输入：KiahWee，那么最终制作好的网址就会变成 linktr.ee&#x2F;KiahWee 二、输入名称和类别第二步，输入你的名称，并根据你的链接类型选择3个对应标签。 这里可以自由选择，因为这两个内容最终都不会出现在我们的链接页面上。 三、选择方案：Linktree 提供免费和付费Pro两个版本，免费版就可以满足我们的一些基础功能，这里建议大家先体验一下免费版本，后面有需求再考虑升级。 四、编辑页面接下来进入编辑页面，主要分为左右两个板块，左边是编辑区，右边为预览模式。 点击左上角的“Appearance”一栏，设置背景颜色和头像。 五、设置头像、背景点击**“Pick an image”**即可上传头像；在**“Themes”**中选择你喜欢的主题背景。 因为这里我们选择的是免费版本，所以对于主题背景的选择会有一些限制。 设置完头像和背景主题后，可以直接在右边的预览区看到设置的效果图。 六、设置链接完成了上面的基础设置后，进入“Links”页面，点击紫色按钮“Add New Link”。 在链接区域输入对应“文字”和“网址链接”： 举个例子，这里我输入Facebook的粉丝专页，并在网址处输入对应链接。 完成上面的操作后，可以通过拖拽区块上下移动位置；右上角则显示了最终生成的专属链接，点击“Share”即可复制网址链接。 第七步、复制黏贴到website我们可以把生成的链接放在TikTok的个人主页，这样进入个人主页的用户就可以进入我们设计好的多链接页面。 最后，粉丝在手机上进入链接看到的最终效果如下： 其实，设置多链接页面的操作流程非常简单，自己实际操作一下，很快就能上手。 想要在TikTok设置多链接页面的伙伴都可以试试！","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"linktree","slug":"linktree","permalink":"http://example.com/tags/linktree/"}],"author":"作者"},{"title":"跨域的五种最常见解决方案","slug":"跨域的五种最常见解决方案","date":"2023-03-07T13:07:38.000Z","updated":"2023-03-07T13:07:38.000Z","comments":true,"path":"2023/03/07/跨域的五种最常见解决方案/","link":"","permalink":"http://example.com/2023/03/07/%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%BA%94%E7%A7%8D%E6%9C%80%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"跨域的五种最常见解决方案什么是跨域？跨域不是问题，是一种安全机制。浏览器有一种策略名为同源策略，同源策略规定了部分请求不能被浏览器所接受。 值得一提的是：同源策略导致的跨域是浏览器单方面拒绝响应数据，服务器端是处理完毕并做出了响应的。 什么是同源策略一个url由三部分组成:协议，域名（ip地址），端口。 只有当协议，域名，端口都一致的时候，才被称为同源。 而同源策略规定，只有发送请求的那一边和接受请求的那一边处于同源的情况下，浏览器才会接受响应。 举个例子 12345发送请求地址:http:47.96.127.5:8080/index 接受请求地址:http:47.96.127.5:8081/index //不同源 端口不同发送请求地址:http:47.96.127.5:8080/index 接受请求地址:http:47.96.127.6:8080/index //不同源 ip不同发送请求地址:http:47.96.127.5:8080/index 接受请求地址:https:47.96.127.5:8080/index //不同源 协议不同发送请求地址:http:47.96.127.5:8080/index 接受请求地址:http:47.96.127.5:8080/login //同源 协议，端口，ip都相同，路径不同无所谓复制代码 而当我们的请求不符合同源策略的时候。往往会出现以下错误👇 解决跨域常见的5种方法第一种:JQuery的ajax(推荐JQuery项目中使用)jq的ajax自带解决跨域的方法。底层原理采用的JSONP的跨域解决方案。如下 1234567891011function callback()&#123; console.log(&quot;月薪一千五，心比美式苦&quot;)&#125;$.ajax(&#123; url: &#x27;http://www.domain2.com:8080/login&#x27;, type: &#x27;get&#x27;, dataType: &#x27;jsonp&#x27;, // 请求方式为jsonp 设置跨域的重点 jsonpCallback: &quot;callBack&quot;, // 回调函数&#125;);复制代码 在JQ项目中，这是最常见的解决方案。 第二种:script标签解决跨域(远古Web项目中使用)如果你的项目是祖传下来的。没有框架连JQuery都没有。没关系，我们可以尝试使用原生的方法去解决。 原生采用的是script标签可以不受跨域限制的特性来实现跨域。 12345678910111213141516 &lt;script&gt; // 回调 function callBack(res) &#123; console.log(&quot;跨域的回调&quot;,res); // ...完成你所有操作后记得删除script↓ document.head.getElementsByClassName(&quot;script&quot;)[0].remove(); &#125; const scriptDom = document.createElement(&#x27;script&#x27;); scriptDom.type = &#x27;text/javascript&#x27;; scriptDom.class = &#x27;script&#x27;; //用于删除 // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数 scriptDom.src = &#x27;http://192.167.0.152:9996/inface?callback=callBack&#x27;; document.head.appendChild(script); //将标签挂载到dom上 &lt;/script&gt;复制代码 这里需要注意的是，使用完请求之后记得删除script,否则会随着请求的变多script标签会一直挂载在DOM上。 在远古的web中，这是一种方案。但现在已经不用了。 vue&#x2F;react&#x2F;jq等框架性项目中不要使用这种方法，不是不行，只是有更好的选择 第三种:前端代理解决跨域每一个框架的代理配置都不太一样。这里仅以我使用的umi.js(react)为例。 Umi.js框架会有 config.ts &#x2F; config.js 文件，文件中会有proxy字段、字段按图中配置方法。即可完成跨域 第四种：服务端代理（Nginx代理）nginx代理一般使用在生产环境。是服务端解决跨域的一种方案。 简单配置模板👇 12345678910#如果监听到请求接口地址是 www.xxx.com/api/page ，nginx就向http://www.yyy.com:9999/api/page这个地址发送请求server &#123; listen 80; server_name www.xxx.com; #判过滤出含有api的请求 location /api/ &#123; proxy_pass http://www.yyy.com:9999; #真实服务器的地址 &#125;&#125;复制代码 注意，nginx配置完代理后需要重启nginx，nginx代理是生产环境的常用方案 第五种:后台（逻辑层）添加响应头解决Access-Control-Allow-Origin响应头的意思是，安全同行的请求。 举个例子 http://192.168.0.103:8080 向http://192.168.0.102:8080 发送了请求，结果因为域名不一样，在返回信息的时候因为IP地址不一致被拦截。 但是如果http://192.168.0.102:8080 在响应头中的 Access-Control-Allow-Origin 字段中携带上属性值’http://192.168.0.103:8080‘ 如下 123//响应头Access-Control-Allow-Origin&#x27;:&#x27;http:/ /192.168.0.103:8080&#x27;复制代码 这就等于告诉浏览器，http://192.168.0.102:8080 这个地址是安全的，请不要拦截。 这样，http://192.168.0.103:8080 就可以接受来自 http://192.168.0.102:8080 返回的信息。 当然，我们也可以进行所有域名均不拦截的设置（如下） 1234//响应头// * 代表所有域名均不拦截Access-Control-Allow-Origin&#x27;:&#x27;*&#x27;复制代码 node案例如下 1234567891011res.writeHead(200, &#123; Access-Control-Allow-Origin&#x27;:&#x27;http://192.168.0.103:8080&#x27;&#125;);//或者res.writeHead(200, &#123; Access-Control-Allow-Origin&#x27;:&#x27;*&#x27;&#125;);复制代码 并不建议此种方案，因为安全性不高。自己写小练习的时候建议使用，因为真的很方便。 总结跨域的常见的五种解决方案如下 jsonp，代表：jquery的$.ajax。（仅限JQuery项目使用） script标签解决跨域（远古web使用的方案，已不建议使用） 前端代理 nginx代理 设置响应头（不建议使用，安全性不高，小练习可以用用，方便） 作者：工边页字链接：https://juejin.cn/post/7194734127390654520来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://example.com/tags/%E8%B7%A8%E5%9F%9F/"}],"author":"作者"},{"title":"被问到《vue2与vue3的区别》该怎么回答","slug":"被问到《vue2与vue3的区别》该怎么回答","date":"2023-03-07T13:05:02.000Z","updated":"2023-03-07T13:05:02.000Z","comments":true,"path":"2023/03/07/被问到《vue2与vue3的区别》该怎么回答/","link":"","permalink":"http://example.com/2023/03/07/%E8%A2%AB%E9%97%AE%E5%88%B0%E3%80%8Avue2%E4%B8%8Evue3%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%8B%E8%AF%A5%E6%80%8E%E4%B9%88%E5%9B%9E%E7%AD%94/","excerpt":"","text":"被问到 《vue2 与 vue3 的区别》应该怎么回答Vue 内部根据功能可以被分为三个大的模块：**响应性 reactivite、运行时 runtime、编辑器 compiler**，以及一些小的功能点。那么要说 vue2 与 vue3 的区别，我们需要从这三个方面加小的功能点进行说起。 首先先来说 **响应性 reactivite**： vue2 的响应性主要依赖 Object.defineProperty 进行实现，但是 Object.defineProperty 只能监听 指定对象的指定属性的 getter 行为和 setter 行为，那么这样在某些情况下就会出现问题。 什么问题呢？ 比如说：我们在 data 中声明了一个对象 person ，但是在后期为 person 增加了新的属性，那么这个新的属性就会失去响应性。想要解决这个问题其实也非常的简单，可以通过 Vue.$set 方法来增加 指定对象指定属性的响应性。但是这样的一种方式，在 Vue 的自动响应性机制中是不合理。 所以在 Vue3 中，Vue 引入了反射和代理的概念，所谓反射指的是 Reflect，所谓代理指的是 Proxy。我们可以利用 Proxy 直接代理一个普通对象，得到一个 proxy 实例 的代理对象。在 vue3 中，这个过程通过 reactive 这个方法进行实现。 但是 proxy 只能实现代理复杂数据类型，所以 vue 额外提供了 ref 方法，用来处理简单数据类型的响应性。ref 本质上并没有进行数据的监听，而是构建了一个 RefImpl 的类，通过 set 和 get 标记了 value 函数，以此来进行的实现。所以 ref 必须要通过 .value 进行触发，之所以要这么做本质是调用 value 方法。 接下来是**运行时 runtime**： 所谓的运行时，大多数时候指的是 renderer 渲染器，渲染器本质上是一个对象，内部主要三个方法 render、hydrate、createApp ，其中 render 主要处理渲染逻辑，hydrate 主要处理服务端渲染逻辑，而 createApp 就是创建 vue 实例的方法。 这里咱们主要来说 render 渲染函数，vue3 中为了保证宿主环境与渲染逻辑的分离，把所有与宿主环境相关的逻辑进行了抽离，通过接口的形式进行传递。这样做的目的其实是为了解绑宿主环境与渲染逻辑，以保证 vue 在非浏览器端的宿主环境下可以正常渲染。 再往下是 **编辑器 compiler**： vue 中的 compiler 其实是一个 DSL（特定领域下专用语言编辑器） ，其目的是为了把 template 模板 编译成 render 函数。 逻辑主要是分成了三大步： parse、transform 和 generate。其中 parse 的作用是为了把 template 转化为 AST（抽象语法树），transform 可以把 AST（抽象语法树） 转化为 JavaScript AST，最后由 generate 把 JavaScript AST 通过转化为 render 函数。转化的过程中会涉及到一些稍微复杂的概念，比如 有限自动状态机 这个就不再这里展开说了。 除此之外，还有一些其他的变化。比如 vue3 新增的 composition API。 composition API 在 vue3.0 和 vue3.2 中会有一些不同的呈现，比如说：最初的 composition API 以 setup 函数作为入口函数， setup 函数必须返回两种类型的值：第一是对象，第二是函数。 当 setup 函数返回对象时，对象中的数据或方法可以在 template 中被使用。当 setup 函数返回函数时，函数会被作为 render 函数。 但是这种 setup 函数的形式并不好，因为所有的逻辑都集中在 setup 函数中，很容易出现一个巨大的 setup 函数，我们把它叫做巨石（屎山）函数。所以 vue 3.2 的时候，新增了一个 script setup 的语法糖，尝试解决这个问题。目前来看 script setup 的呈现还是非常不错的。 除此之外还有一些小的变化，比如 Fragment、Teleport、Suspense 等等，这些就不去说了…","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}],"author":"作者"},{"title":"使用router-link-active和exact动态切换路由样式","slug":"使用router-link-active和exact动态切换路由样式","date":"2022-11-05T05:47:13.000Z","updated":"2022-11-05T05:47:13.000Z","comments":true,"path":"2022/11/05/使用router-link-active和exact动态切换路由样式/","link":"","permalink":"http://example.com/2022/11/05/%E4%BD%BF%E7%94%A8router-link-active%E5%92%8Cexact%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E8%B7%AF%E7%94%B1%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"使用router-link-active和exact动态切换路由样式每个router-link标签被点击时都有一个router-link-active的类，设置这个类的样式，就可以在vue里实现类的动态切换，在每个router-link标签里，都要加上exact这个属性，才能正常切换。 例子： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt;&lt;div&gt; &lt;!-- 每个router-link标签里都要加上exact属性 --&gt; &lt;router-link :to=&quot;&#123;name:&#x27;Home&#x27;&#125;&quot; exact&gt;&lt;span&gt;home&lt;/span&gt;&lt;/router-link&gt; &lt;router-link :to=&quot;&#123;name:&#x27;Test&#x27;&#125;&quot; exact&gt;&lt;span&gt;Test&lt;/span&gt;&lt;/router-link&gt; &lt;router-link :to=&quot;&#123;name:&#x27;News&#x27;&#125;&quot; exact&gt;&lt;span&gt;News&lt;/span&gt;&lt;/router-link&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;CommonHeader&quot;, data () &#123; return &#123; &#125;; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot; scoped&gt;/* router-link标签会默认渲染为a标签 */a&#123; display: inline-block; width: 120px; height:50px ; line-height: 50px; text-decoration: none; color: #333;&#125;/* 当router-link被点击时候的样式 */.router-link-active&#123; display: inline-block; width: 120px; height:50px ; line-height: 50px; text-decoration: none; color: #fff; background-color: red;&#125;&lt;/style&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}],"author":"作者"},{"title":"vue项目打包时的优化学习","slug":"vue项目打包时的优化学习","date":"2022-11-03T16:14:29.000Z","updated":"2022-11-03T16:14:29.000Z","comments":true,"path":"2022/11/04/vue项目打包时的优化学习/","link":"","permalink":"http://example.com/2022/11/04/vue%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%97%B6%E7%9A%84%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1.项目优化1.1项目可优化的内容 生成打包报告 第三方库启用CDN Element-ui组件按需加载 路由懒加载 首页内容定制 1.2页面顶部进度条效果使用nprogess第三方库 在axios请求拦截器中触发 Nprogress.start() 在axios响应拦截器中触发 Nprogress.done() 1.3 打包时的优化1.3.1清除console使用babel-plugin-transform-remove-console 1安装：npm install babel-plugin-transform-remove-console --save-dev 123456.babelrc: // 全部清除console&#123; &quot;plugins&quot;: [&quot;transform-remove-console&quot;]&#125; 12345// with options选择性删除&#123; &quot;plugins&quot;: [ [&quot;transform-remove-console&quot;, &#123; &quot;exclude&quot;: [ &quot;error&quot;, &quot;warn&quot;] &#125;] ]&#125; 1.3.2 区分开发和生产环境下使用 babel-plugin-transform-remove-console123456789101112131415161718192021222324252627282930313233343536373839404142434445// babel.config.js文件里// 定义一个生产环境的插件数组const prodPlugins = []// 如果是生产环境则添加&#x27;transform-remove-console&#x27;if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; prodPlugins.push(&#x27;transform-remove-console&#x27;)&#125;module.exports = &#123; presets: [ &#x27;@vue/cli-plugin-babel/preset&#x27; ], plugins: [ [ &#x27;component&#x27;, &#123; libraryName: &#x27;element-ui&#x27;, styleLibraryName: &#x27;theme-chalk&#x27; &#125; ], // 将生产环境的数组展开到配置中 ...prodPlugins ]&#125; 1.4 生成打包报告打包时，为了直观地发现项目中存在的问题，可以生成打包报告。 1.4.1 通过命令行参数的形式生成报告12345// 通过vue-cli的命令选项可以生成打包报告// --report选项可以生成report.html以帮助分析报告内容vue-cli-service build --report 1.4.2 通过可视化的UI面板直接查看报告 通过仪表盘和分析面板可以看到加载速度和依赖项资源大小占比，从而进一步优化。 1.5 通过vue.config.js修改webpack的默认配置 vue-cli3.0+工具生成的项目，默认隐藏了所有webpack的配置项，这样做的目的时屏蔽项目中的所有配置，让重心放在项目功能和业务逻辑上，省去配置带了的各种繁琐配置事项。 vue.config.js官方文档：vue.config.js官方文档 1.6 为开发模式与发布模式指定不同的打包入口 默认情况下，vue项目中的开发模式和发布模式，共同使用哟个打包的入口文件（src&#x2F;main.js）。为了分离开发陌生和发布模式，可以指定不同的打包入口文件。 开发模式的入口文件为src&#x2F;main-dev.js 生产模式的入口文件为src&#x2F;main-prod.js 1.6.1 configureWebpack和chainWebpack在vue.config.js中，新增configureWebpack和chainWebpack节点自定义打包配置。 configureWebpack和chainWebpack作用相同。唯一的区别是修改方式不同： ① chainWebpack链式编程形式，来改变webpack的默认配置 ② configureWebpack通过操作对象的形式，来改变webpack的默认配置 参考vue.config.js官方文档：vue.config.js官方文档 1.6.2 通过chainWebpack自定义打包入口代码示列： 123456789101112131415// vue.config.jsmodule.exports = &#123; chainWebpack:config=&gt;&#123; //发布模式 config.when(process.env.NODE_ENV === &#x27;production&#x27;,config=&gt;&#123; //entry找到默认的打包入口，调用clear则是删除默认的打包入口 //add添加新的打包入口 config.entry(&#x27;app&#x27;).clear().add(&#x27;./src/main-prod.js&#x27;) &#125;) //开发模式 config.when(process.env.NODE_ENV === &#x27;development&#x27;,config=&gt;&#123; config.entry(&#x27;app&#x27;).clear().add(&#x27;./src/main-dev.js&#x27;) &#125;) &#125;&#125; 1.7 通过extrenals加载外部CDN资源默认情况下，通过import语法导入的第三方依赖包，最终会被打包合并到同一个文件中，从而导致打包成功后的文件体积过大。 解决办法：通过webpack的externals节点，来配置并加载外部的CDN资源，凡是声明在externals中的第三方依赖包，都不会被打包。 步骤一：声明需要外部CDN的项目 12345678910//使用externals设置排除项config.set(&#x27;externals&#x27;,&#123; vue:&#x27;Vue&#x27;, &#x27;vue-router&#x27;:&#x27;VueRouter&#x27;, axios:&#x27;axios&#x27;, lodash:&#x27;_&#x27;, echarts:&#x27;echarts&#x27;, nprogress:&#x27;NProgress&#x27;, &#x27;vue-quill-editor&#x27;:&#x27;VueQuillEditor&#x27;&#125;) 步骤二：在public&#x2F;index.html文件头部添加CDN样式css资源 123456&lt;!-- nprogress 的样式表文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css&quot; /&gt;&lt;!-- 富文本编辑器 的样式表文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/quill/1.3.4/quill.core.min.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/quill/1.3.4/quill.snow.min.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/quill/1.3.4/quill.bubble.min.css&quot; /&gt; 步骤三：在public&#x2F;index.html文件头部添加CDN样式js资源 123456789&lt;script src=&quot;https://cdn.staticfile.org/vue/2.5.22/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.staticfile.org/vue-router/3.0.1/vue-router.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.staticfile.org/axios/0.18.0/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.staticfile.org/lodash.js/4.17.11/lodash.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.staticfile.org/echarts/4.1.0/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 富文本编辑器的 js 文件 --&gt;&lt;script src=&quot;https://cdn.staticfile.org/quill/1.3.4/quill.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue-quill-editor@3.0.4/dist/vue-quill-editor.js&quot;&gt;&lt;/script&gt; 1.8 通过CDN优化ElementUi的打包操作流程如下： ① 在main.js入口文件，注释掉element-ui的加载代码 ② 在index.thml的头部区域中，通过CDN加载element-ui的js和css样式 1234&lt;!-- element-ui 的样式表文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/element-ui/2.8.2/theme-chalk/index.css&quot; /&gt;&lt;!-- element-ui 的 js 文件 --&gt;&lt;script src=&quot;https://cdn.staticfile.org/element-ui/2.8.2/index.js&quot;&gt;&lt;/script&gt; 1.9 首页内容定制(按需渲染)开发环境的首页和发布环境的首页展示内容的形式有所不同。 如开发环境中使用的是import加载第三方包，而发布环境则是使用CDN，那么首页也需根据环境不同来进行不同的实现。 可以通过插件的方式来定制首页内容，打开vue.config.js，编写代码如下： 12345678910111213141516171819202122232425module.exports = &#123; chainWebpack:config=&gt;&#123; config.when(process.env.NODE_ENV === &#x27;production&#x27;,config=&gt;&#123; ...... // 使用htmlWebpackPlugin插件 config.plugin(&#x27;html&#x27;).tap(args=&gt;&#123; // 添加参数isProd，通过isProd来判断是否渲染 args[0].isProd = true return args &#125;) &#125;) config.when(process.env.NODE_ENV === &#x27;development&#x27;,config=&gt;&#123; config.entry(&#x27;app&#x27;).clear().add(&#x27;./src/main-dev.js&#x27;) // 使用插件 config.plugin(&#x27;html&#x27;).tap(args=&gt;&#123; // 添加参数isProd args[0].isProd = false return args &#125;) &#125;) &#125;&#125; 然后在public&#x2F;index.html中使用插件判断是否为发布环境并定制首页内容: 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.isProd ? &#x27;&#x27; : &#x27;dev - &#x27; %&gt;电商后台管理系统&lt;/title&gt; &lt;% if(htmlWebpackPlugin.options.isProd)&#123; %&gt; &lt;!-- nprogress 的样式表文件 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css&quot; /&gt; ........ &lt;!-- element-ui 的 js 文件 --&gt; &lt;script src=&quot;https://cdn.staticfile.org/element-ui/2.8.2/index.js&quot;&gt;&lt;/script&gt; &lt;% &#125; %&gt; &lt;/head&gt; 2. 项目上线2.1 项目上线相关配置 通过nodejs创建web服务器 开启gzip压缩配置 配置https服务 使用pm2管理应用 2.1.1 通过node创建web服务器创建node项目，并安装express，通过express快速下黄健web服务器，将打包的vue项目，托管为静态资源。 代码如下： 123456789const express = require(&#x27;express&#x27;)const app = express()app.use(express.static(&#x27;./dist&#x27;))app.listen(8998,()=&gt;&#123; console.log(&quot;server running at http://127.0.0.1:8998&quot;)&#125;) 2.1.2 开启gzip配置使用gzip可以减小文件体积，是传输速度更快。 可以通过服务端使用express做gzip，配置如下： 12345678910111213// 安装compression ：npm i compression -Dconst express = require(&#x27;express&#x27;)// 导入包const compression = require(&#x27;compression&#x27;)const app = express()// 启用中间件app.use(compression())app.use(express.static(&#x27;./dist&#x27;))app.listen(8998,()=&gt;&#123; console.log(&quot;server running at http://127.0.0.1:8998&quot;)&#125;) 2.1.3 配置HTTPS服务配置https服务一般是后台进行处理，前端开发人员了解即可。 首先，需要申请SSL证书，进入https://freessl.cn官网 在后台导入证书，打开今天资料&#x2F;素材，复制素材中的两个文件到vue_shop_server中 打开app.js文件，编写代码导入证书，并开启https服务 123456789101112131415161718192021const express = require(&#x27;express&#x27;)const compression = require(&#x27;compression&#x27;)const https = require(&#x27;https&#x27;)const fs = require(&#x27;fs&#x27;)const app = express()//创建配置对象设置公钥和私钥const options = &#123; cert:fs.readFileSync(&#x27;./full_chain.pem&#x27;), key:fs.readFileSync(&#x27;./private.key&#x27;)&#125;app.use(compression())app.use(express.static(&#x27;./dist&#x27;))// app.listen(8998,()=&gt;&#123;// console.log(&quot;server running at http://127.0.0.1:8998&quot;)// &#125;)//启动https服务https.createServer(options,app).listen(443) 2.1.4 使用pm2管理应用打开vue_shop_server文件夹的终端，输入命令：npm i pm2 -g 使用pm2启动项目，在终端中输入命令：pm2 start app.js –name 自定义名称 查看项目列表命令：pm2 ls 重启项目：pm2 restart 自定义名称 停止项目：pm2 stop 自定义名称 删除项目：pm2 delete 自定义名称","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端优化","slug":"前端优化","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"}],"author":"作者"},{"title":"git提交规范","slug":"git提交规范","date":"2022-11-01T18:07:11.000Z","updated":"2022-11-01T18:07:11.000Z","comments":true,"path":"2022/11/02/git提交规范/","link":"","permalink":"http://example.com/2022/11/02/git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/","excerpt":"","text":"1.windows 全局安装commitizennode模块1npm install -g commitizen@4.2.4 注意：一定要在当前windows用户下全局安装，不是在项目内安装 2.在需要使用Commitizen规范的项目内执行注意前提该项目根目录上已有package.json文件 1234commitizen init cz-conventional-changelog --save --save-exactorcommitizen init cz-conventional-changelog --save --save-exact --force 安装成功后检查package.json文件，如新增以下配置代表安装成功 12345&quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot; &#125;&#125; 3.测试命令1git cz 显示（成功）： 1234567891011 cz-cli@4.2.4, cz-conventional-changelog@3.3.0 ? Select the type of change that you&#x27;re committing: (Use arrow keys) feat: A new featurefix: A bug fixdocs: Documentation only changesstyle: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) refactor: A code change that neither fixes a bug nor adds a featureperf: A code change that improves performancetest: Adding missing tests or correcting existing tests (Move up and down to reveal more choices) 4.可自定义提交规范(汉化后可能涉及到无法进行校验)1、执行以下命令，并且在项目根目录创建.cz-config.js1$ npm i -D commitlint-config-cz cz-customizable 2、cz-config.js 文件（网上比较好的一个配置文件，可借鉴）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 方案一&quot;use strict&quot;;module.exports = &#123; types: [ &#123; value: &quot;✨特性&quot;, name: &quot;特性: 一个新的特性&quot; &#125;, &#123; value: &quot;🐛修复&quot;, name: &quot;修复: 修复一个Bug&quot; &#125;, &#123; value: &quot;📝文档&quot;, name: &quot;文档: 变更的只有文档&quot; &#125;, &#123; value: &quot;💄格式&quot;, name: &quot;格式: 空格, 分号等格式修复&quot; &#125;, &#123; value: &quot;♻️重构&quot;, name: &quot;重构: 代码重构，注意和特性、修复区分开&quot; &#125;, &#123; value: &quot;⚡️性能&quot;, name: &quot;性能: 提升性能&quot; &#125;, &#123; value: &quot;✅测试&quot;, name: &quot;测试: 添加一个测试&quot; &#125;, &#123; value: &quot;🔧工具&quot;, name: &quot;工具: 开发工具变动(构建、脚手架工具等)&quot; &#125;, &#123; value: &quot;⏪回滚&quot;, name: &quot;回滚: 代码回退&quot; &#125;, ], scopes: [ &#123; name: &quot;模块1&quot; &#125;, &#123; name: &quot;模块2&quot; &#125;, &#123; name: &quot;模块3&quot; &#125;, &#123; name: &quot;模块4&quot; &#125;, ], messages: &#123; type: &quot;选择一种你的提交类型:&quot;, scope: &quot;选择一个scope (可选):&quot;, // used if allowCustomScopes is true customScope: &quot;Denote the SCOPE of this change:&quot;, subject: &quot;短说明:\\n&quot;, body: &#x27;长说明，使用&quot;|&quot;换行(可选)：\\n&#x27;, breaking: &quot;非兼容性说明 (可选):\\n&quot;, footer: &quot;关联关闭的issue，例如：#31, #34(可选):\\n&quot;, confirmCommit: &quot;确定提交说明?&quot;, &#125;, allowCustomScopes: true, allowBreakingChanges: [&quot;特性&quot;, &quot;修复&quot;], // limit subject length subjectLimit: 100,&#125;;// 方案二module.exports = &#123; // 可选类型 types: [ &#123; value: &#x27;feat&#x27;, name: &#x27;feat: 新功能&#x27; &#125;, &#123; value: &#x27;fix&#x27;, name: &#x27;fix: 修复&#x27; &#125;, &#123; value: &#x27;docs&#x27;, name: &#x27;docs: 文档变更&#x27; &#125;, &#123; value: &#x27;style&#x27;, name: &#x27;style: 代码格式(不影响代码运行的变动)&#x27; &#125;, &#123; value: &#x27;refactor&#x27;, name: &#x27;refactor: 重构(既不是增加feature，也不是修复bug)&#x27; &#125;, &#123; value: &#x27;perf&#x27;, name: &#x27;perf: 性能优化&#x27; &#125;, &#123; value: &#x27;test&#x27;, name: &#x27;test: 增加测试&#x27; &#125;, &#123; value: &#x27;chore&#x27;, name: &#x27;chore: 构建过程或辅助工具的变动&#x27; &#125;, &#123; value: &#x27;revert&#x27;, name: &#x27;revert: 回退&#x27; &#125;, &#123; value: &#x27;build&#x27;, name: &#x27;build: 打包&#x27; &#125; ], // 消息步骤 messages: &#123; type: &#x27;请选择提交类型:&#x27;, customScope: &#x27;请输入修改范围(可选):&#x27;, subject: &#x27;请简要描述提交(必填):&#x27;, body: &#x27;请输入详细描述(可选):&#x27;, footer: &#x27;请输入要关闭的issue(可选):&#x27;, confirmCommit: &#x27;确认使用以上信息提交？(y/n/e/h)&#x27; &#125;, // 跳过问题 skipQuestions: [&#x27;body&#x27;, &#x27;footer&#x27;], // subject文字长度默认是72 subjectLimit: 72&#125; 5.新建文件commitlint.config.js（若存在.commitlintrc.js文件，需先删除）123456module.exports = &#123; extends: [ &#x27;cz&#x27; ]&#125; 6.使用git cz替代git commit以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。注意：使用之前，确保根目录下有.gitignore这个文件并且配置把node_modules目录pass掉，不然git add . 的时候会卡死 执行git cz：选择一个fix作为测试：翻译下意思就是说：1.选择你要提交更改的类型2.这个提交变化的范围（你的提交改动了哪些内容的意思）3.写一篇简短的的描述，严谨的描述下这次的变化4.提供下详细的变更描述5.这个提交有破坏性的变化吗？6.这个变化会影响一些开放的issue吗？ 查看一下结果","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}],"author":"作者"},{"title":"vue面试题01","slug":"vue面试题01","date":"2022-11-01T03:11:18.000Z","updated":"2022-11-01T03:11:18.000Z","comments":true,"path":"2022/11/01/vue面试题01/","link":"","permalink":"http://example.com/2022/11/01/vue%E9%9D%A2%E8%AF%95%E9%A2%9801/","excerpt":"","text":"为了金三银四的跳槽季做准备，并且我是 vue 技术栈的，所以整理了若干个 vue 的面试题。 每次看别人的博客，都会不自主的去看答案，为了方便检验自己的掌握程度，我特意将答案折叠起来，大家可以先看题目，在脑海中想象一下如果你被问到会怎么回答，然后再展开答案看看和自己的答案有什么不同。 答案非官方，仁者见仁智者见智，仅供参考。 基础使用MVVM、MVC有什么区别 MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。 其中 View 负责页面的显示逻辑， Model 负责存储页面的业务数据，以及对相应数据的操作。 Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。 MVVM 分为 Model、View、ViewModel。 Model 代表数据模型，数据和业务逻辑都在 Model 层中定义； View 代表 UI 视图，负责数据的展示； ViewMode 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作； Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。 这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作 DOM。 Vue 并没有完全遵循 MVVM 思想呢？ 严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 提供了 $refs 这个属性，让 Model 可以直接操作 View，违反了这一规定，所以说 Vue 没有完全遵循 MVVM。 Vue的优点 渐进式框架：可以在任何项目中轻易的引入； 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ； 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习； 双向数据绑定：在数据操作方面更为简单； 组件化：很大程度上实现了逻辑的封装和重用，在构建单页面应用方面有着独特的优势； 视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作； 对 SPA 单页面的理解，它的优缺点分别是什么？ SPA 仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。 优点： 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 有利于前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理； 缺点： 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载； 不利于 SEO：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 怎样理解 Vue 的单向数据流？ 父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。在子组件内部改变 prop 的时候 ， Vue 会在浏览器的控制台中发出警告。 子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。 有两种常见的试图改变一个 prop 的情形 : 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。&nbsp;在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值： 这个 prop 以一种原始的值传入且需要进行转换。&nbsp;在这种情况下，最好使用这个 prop 的值来定义一个计算属性 Data为什么是一个函数？ 因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。 Computed和Watch 有什么区别？ 对于Computed： 它支持缓存，只有依赖的数据发生了变化，才会重新计算 不支持异步，当 Computed 中有异步操作时，无法监听数据的变化 如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用 computed 如果 computed 属性的属性值是函数，那么默认使用 get 方法，函数的返回值就是属性的属性值；在 computed 中，属性有一个 get 方法和一个 set 方法，当数据发生变化时，会调用 set 方法。 对于Watch： 它不支持缓存，当一个属性发生变化时，它就会触发相应的操作 支持异步监听 监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值 监听数据必须是 data 中声明的或者父组件传递过来的 props 中的数据，当发生变化时，会触发其他操作 函数有两个的参数： immediate：组件加载立即触发回调函数 deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。 Computed 和 Methods 的区别 共同点： 可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的。 不同点： computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值； method: 调用总会执行该函数。 .Sync的作用是什么？ vue 修饰符 sync 的功能是：当父组件提供了一个数据，而子组件想要去更改这个数据，但是 Vue 的规则不能让子组件去修改父组件的数据，就需要通过&nbsp;this.$emit&nbsp;和&nbsp;$event，来实现数据修改的目的。 :money.sync=\"total\" // 等价于 :money=\"total\" v-on:update:money=\"total = $event\" 复制代码 绑定事件@click&#x3D;handler 和@click&#x3D;handler（） 那个正确？有什么区别？ 都可以，不带括号会传进来一个事件对象，带括号的不会 事件有哪些修饰符？ 「事件修饰符」 .stop 阻止事件继续传播 .prevent 阻止标签默认行为 .capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 .self 只当在 event.target 是当前元素自身时触发处理函数 .once 事件将只会触发一次 .passive 告诉浏览器你不想阻止事件的默认行为 「v-model 的修饰符」 .lazy 通过这个修饰符，转变为在 change 事件再同步 .number 自动将用户的输入值转化为数值类型 .trim 自动过滤用户输入的首尾空格 「键盘事件的修饰符」 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 「系统修饰键」 .ctrl .alt .shift .meta 「鼠标按钮修饰符」 .left .right .middle 什么是插槽？具名插槽？作用域插槽？原理是什么？ slot 又名插槽，是 Vue 的内容分发机制，插槽 slot 是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot 又分三类，默认插槽，具名插槽和作用域插槽。 默认插槽：又名匿名插槽，当 slot 没有指定 name 属性值的时候，默认显示的插槽，一个组件内只允许有一个匿名插槽。 具名插槽：带有具体名字的插槽，也就是带有 name 属性的 slot，一个组件可以出现多个具名插槽。 作用域插槽：可以是匿名插槽，也可以是具名插槽，该插槽在渲染时，父组件可以使用子组件内部的数据。 实现原理：当子组件 vm 实例化时，获取到父组件传入的 slot 标签的内容，存放在 vm.$slot 中，默认插槽为 vm.$slot.default，具名插槽为 vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到 slot 标签，使用 $slot 中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。 Vue中如何实现过度效果？如何实现列表过度？ 过渡效果，当然只有 dom 从显示到隐藏或隐藏到显示才能用 Vue.js 为我们提供了内置的过渡组件 transition 和 transition-group Vue 将元素的过渡分为四个阶段，进入前，进入后，消失前，消失后 支持 mode 属性，可选值： in-out:要进入的先进入，然后要消失的再消失 out-in:要消失的先消失，然后要进入的再进入 多个元素需要加上过渡效果可以使用 name 属性进行区分。 可以配合 animate.css 实现更多的动画效果。 过滤器的作用，如何实现一个过滤器 过滤器是用来过滤数据的，在 Vue 选项中声明 filters 来实现一个过滤器，filters不会修改数据，而是处理数据，改变用户看到的输出。 使用场景： 需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。 比如后端返回一个 年月日的日期字符串，前端需要展示为 多少天前 的数据格式，此时就可以用fliters 过滤器来处理数据。 过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在 插值表达式 &#123;&#123; &#125;&#125; 和 v-bind 表达式 中，然后放在操作符 | 后面进行指示。 例如，在显示金额，给商品价格添加单位： &lt;li&gt;商品价格：&#123;&#123;item.price | filterPrice&#125;&#125;&lt;/li&gt; filters: &#123; filterPrice (price) &#123; return price ? (‘￥’ + price) : ‘–’ &#125; &#125;复制代码 assets和static的区别 相同点：&nbsp;assets&nbsp;和&nbsp;static&nbsp;两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点 不相同点： assets&nbsp;中存放的静态资源文件在项目打包时，也就是运行&nbsp;npm run build&nbsp;时会将&nbsp;assets&nbsp;中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在&nbsp;static&nbsp;文件中跟着&nbsp;index.html&nbsp;一同上传至服务器。static&nbsp;中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是&nbsp;static&nbsp;中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于&nbsp;assets&nbsp;中打包后的文件提交较大点。在服务器中就会占据更大的空间。 建议：&nbsp;将项目中&nbsp;template需要的样式文件js文件等都可以放置在&nbsp;assets&nbsp;中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css&nbsp;等文件可以放置在&nbsp;static&nbsp;中，因为这些引入的第三方文件已经经过处理，我们不再需要处理，直接上传。 对SSR的理解 SSR 大致的意思就是 vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端，这个过程就叫做服务端渲染。 （1）服务端渲染的优点： 更好的 SEO：SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面； 首屏加载更快：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间； （2) 服务端渲染的缺点： 更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数， 不能进行 dom 操作。 这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行。 Vue的性能优化有哪些 （1）代码层面的优化 v-if 和 v-show 区分使用场景 computed 和 watch 区分使用场景 v-for 遍历必须为 item 添加 key，且避免同时使用 v-if 长列表性能优化 事件的销毁 图片资源懒加载 路由懒加载 第三方插件的按需引入 优化无限列表性能 服务端渲染 （2）Webpack 层面的优化 Webpack 对图片进行压缩 减少 ES6 转为 ES5 的冗余代码 提取公共代码 模板预编译 提取组件的 CSS 优化 SourceMap 构建结果输出分析 Vue 项目的编译优化 （3）基础的 Web 技术的优化 开启 gzip 压缩 浏览器缓存 CDN 的使用 使用 Chrome Performance 查找性能瓶颈 Vue的首屏加载性能优化有哪些 优化前的大小 1.图片优化 之前为了方便开法， 背景图片直接在 assets 里面扔了一个 jpg ， 导致加载这张图片的时候就用了十几秒， 于是乎我就把图片上传空间了， 然后改用网络地址。 2.禁止生成.map文件 build 出来的 dist 文件夹里面有很多的 .map 文件,这些文件主要是帮助线上调试代码，禁止生成这些文件. 在 vue.config.js 里面加上这句。 3.路由懒加载 4.cdn引入公共库 &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt; &lt;script src=\"https://cdn.bootcss.com/vue/2.6.11/vue.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/vuex/3.0.1/vuex.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/axios/0.19.2/axios.min.js\"&gt;&lt;/script&gt; 复制代码 //cdn引入 configureWebpack: &#123; externals: &#123; 'vue': 'Vue', 'element-ui': 'ELEMENT', 'vue-router': 'VueRouter', 'vuex': 'Vuex', 'axios': 'axios' &#125; &#125; 复制代码 网上说可以把 import 注释掉，亲自操作会报错，也有资料说不用注释也不会打包。 一顿操作最后的文件,效果显著，app.js还是很大 5.终极法宝 GZIP压缩 做完这个感觉前四步都是小菜一碟，直接把 1.4m 的 app.js 干成一百多 kb ,其他的都不足挂齿了。 configureWebpack: config =&gt; &#123; return &#123; //配置cdn externals: &#123; 'vue': 'Vue', 'element-ui': 'ELEMENT', 'vue-router': 'VueRouter', 'vuex': 'Vuex', 'axios': 'axios' &#125;, //配置gzip压缩 plugins: [ new CompressionWebpackPlugin(&#123; &lt;span class=&quot;hljs-attr&quot;&gt;test&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;RegExp&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&#39;\\.(js|css)$&#39;&lt;/span&gt;), &lt;span class=&quot;hljs-attr&quot;&gt;threshold&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;10240&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;minRatio&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0.8&lt;/span&gt; &#125;) ], &#125; &#125; 复制代码 服务端也要配，不然不认识 GZIP 文件。 //配置GZIP压缩模块 const compression = require('compression'); //在所有中间件之前引入 app.use(compression()); 复制代码 最垃圾的服务器通过以上几个优化,一样飞起来了!!! vue初始化页面闪动问题 使用 vue 开发时，在 vue 初始化之前，由于&nbsp;div&nbsp;是不归&nbsp;vue&nbsp;管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于&nbsp;&#123;&#123;message&#125;&#125;&nbsp;的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。 首先：在 css 里加上&nbsp;[v-cloak] &#123; display: none; &#125;&nbsp;。如果没有彻底解决问题，则在根元素加上 style=\"display: none;\" :style=\"&#123;display: &nbsp;block &#125;\" Class 与 Style 如何动态绑定？ Class 可以通过对象语法和数组语法进行动态绑定： 对象语法： &lt;div&nbsp;v-bind:class=\"&#123;&nbsp;active:&nbsp;isActive,&nbsp;'text-danger':&nbsp;hasError&nbsp;&#125;\"&gt;&lt;/div&gt; data:&amp;nbsp;&#123;&amp;nbsp;&amp;nbsp;isActive:&amp;nbsp;true,&amp;nbsp;&amp;nbsp;hasError:&amp;nbsp;false&#125;复制代码 数组语法： &lt;div&nbsp;v-bind:class=\"[isActive&nbsp;?&nbsp;activeClass&nbsp;:&nbsp;'',&nbsp;errorClass]\"&gt;&lt;/div&gt; data:&amp;nbsp;&#123;&amp;nbsp;&amp;nbsp;activeClass:&amp;nbsp;‘active’,&amp;nbsp;&amp;nbsp;errorClass:&amp;nbsp;‘text-danger’&#125;复制代码 Style 也可以通过对象语法和数组语法进行动态绑定： 对象语法： &lt;div&nbsp;v-bind:style=\"&#123;&nbsp;color:&nbsp;activeColor,&nbsp;fontSize:&nbsp;fontSize&nbsp;+&nbsp;'px'&nbsp;&#125;\"&gt;&lt;/div&gt; data:&amp;nbsp;&#123;&amp;nbsp;&amp;nbsp;activeColor:&amp;nbsp;‘red’,&amp;nbsp;&amp;nbsp;fontSize:&amp;nbsp;30&#125;复制代码 数组语法： &lt;div&nbsp;v-bind:style=\"[styleColor,&nbsp;styleSize]\"&gt;&lt;/div&gt; data:&amp;nbsp;&#123;&amp;nbsp;&amp;nbsp;styleColor:&amp;nbsp;&#123;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;color:&amp;nbsp;‘red’&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;,&amp;nbsp;&amp;nbsp;styleSize:&#123;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;fontSize:‘23px’&amp;nbsp;&amp;nbsp;&#125;&#125;复制代码 如何让CSS只在当前组件中起作用? 在组件中的&nbsp;style&nbsp;标签中加上&nbsp;scoped 如何获取dom ref=\"domName\"&nbsp;用法：this.$refs.domName vue-loader是什么？使用它的用途有哪些？ vue 文件的一个加载器，把 template/js/style转换成 js 模块。 生命周期Vue有哪些生命周期钩子? Vue 的生命周期钩子核心实现是利用发布订阅模式先把用户传入的的生命周期钩子订阅好（内部采用数组的方式存储）然后在创建组件实例的过程中会一次执行对应的钩子方法（发布）。 beforeCreate：是 new Vue() 之后触发的第一个钩子，在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。 created：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。可以做一些初始数据的获取，在当前阶段无法与 Dom 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 Dom。 beforeMount：发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段虚拟 Dom 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 updated。 mounted：在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点，使用 $refs 属性对 Dom 进行操作。 beforeUpdate：发生在更新之前，也就是响应式数据发生更新，虚拟 dom 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。 updated：发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。 beforeDestroy：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。 destroyed：发生在实例销毁之后，这个时候只剩下了 dom 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。 如果需要发送异步请求，最好放在哪个钩子内？ 可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。 推荐在 created 钩子函数中调用异步请求，有以下优点： 能更快获取到服务端数据，减少页面 loading 时间； ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性； 第一次页面加载会触发哪几个钩子？ beforeCreate，created，beforeMount，mounted 哪个钩子可以进行dom操作？ 在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。 父子组件嵌套时，父组件和子组件生命周期钩子执行顺序是什么？ Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分： 加载渲染过程 父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted 子组件更新过程 父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated 父组件更新过程 父beforeUpdate -&gt; 父updated 销毁过程 父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed 父子组件嵌套时，父组件视图和子组件视图谁先完成渲染？ 加载渲染过程 父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted 可知子组件先完成渲染 keep-alive 中的生命周期哪些 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。 指令相关说说 vue 内置指令 什么是自定义指令？有哪些生命周期？ 是 vue 对 HTML 元素的扩展，给 HTML 元素增加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。 自定义指令有五个生命周期 bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用&nbsp;(仅保证父节点存在，但不一定已被插入文档中)。 update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。 componentUpdated：被绑定元素所在模板完成一次更新周期时调用。 unbind：只调用一次，指令与元素解绑时调用。 v-text和v-html 有什么区别？ v-text 和 &#123;&#123;&#125;&#125; 表达式渲染数据，不解析标签。 v-html 不仅可以渲染数据，而且可以解析标签。 v-if和v-for的优先级 当&nbsp;v-if&nbsp;与&nbsp;v-for&nbsp;一起使用时，v-for&nbsp;具有比&nbsp;v-if&nbsp;更高的优先级，这意味着&nbsp;v-if&nbsp;将分别重复运行于每个&nbsp;v-for&nbsp;循环中。所以，不推荐&nbsp;v-if&nbsp;和&nbsp;v-for&nbsp;同时使用。如果&nbsp;v-if&nbsp;和&nbsp;v-for&nbsp;一起用的话，vue 中的的会自动提示&nbsp;v-if&nbsp;应该放到外层去。 V-if和v-show有什么区别？ 手段：v-if 是动态的向 DOM 树内添加或者删除 DOM 元素；v-show 是通过设置 DOM 元素的 display 样式属性控制显隐； 编译过程：v-if 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show 只是简单的基于 css 切换； 编译条件：v-if 是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show 是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且 DOM 元素保留； 性能消耗：v-if 有更高的切换消耗；v-show 有更高的初始渲染消耗； 使用场景：v-if 适合运营条件不大可能改变；v-show 适合频繁切换。 组件的v-model是如何实现的？ 我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 以 input 表单元素为例： &lt;input&nbsp;v-model='something'&gt; &nbsp;&nbsp;&nbsp;&nbsp; // 相当于 &lt;input&amp;nbsp;v-bind:value&#x3D;“something”&amp;nbsp;v-on:input&#x3D;“something&amp;nbsp;&#x3D;&amp;nbsp;$event.target.value”&gt;复制代码 v-model 可以被用在自定义组件上吗？如果可以，如何使用？ 如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示： 父组件： &lt;ModelChild&nbsp;v-model=\"message\"&gt;&lt;/ModelChild&gt; 复制代码 子组件： &lt;div&gt;&#123;&#123;value&#125;&#125;&lt;/div&gt; props:&#123;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;value:&amp;nbsp;String&#125;,methods:&amp;nbsp;&#123;&amp;nbsp;&amp;nbsp;test1()&#123;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.$emit(‘input’,&amp;nbsp;‘小红’)&amp;nbsp;&amp;nbsp;&#125;,&#125;,复制代码 v-on可以监听多个方法吗？ 可以 &lt;input type=\"text\" v-on=\"&#123; input:onInput,focus:onFocus,blur:onBlur, &#125;\"&gt; 复制代码 组件相关组件通信的N种方式 （1）props / $emit&nbsp;适用 父子组件通信 （2）ref&nbsp;适用 父子组件通信 ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 （3）$parent&nbsp;/&nbsp;$children /&nbsp;$root：访问父 / 子实例 / 根实例 （4）EventBus （$emit / $on）&nbsp;适用于 父子、隔代、兄弟组件通信 这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。 （5）$attrs/$listeners&nbsp;适用于 隔代组件通信 $attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过&nbsp;v-bind=\"$attrs\"&nbsp;传入内部组件。通常配合 inheritAttrs 选项一起使用。 $listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过&nbsp;v-on=\"$listeners\"&nbsp;传入内部组件 （6）provide / inject&nbsp;适用于 隔代组件通信 祖先组件中通过 provide 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。 （7）Vuex 适用于 父子、隔代、兄弟组件通信 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。store 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 （8）插槽 Vue3 可以通过 usesolt 获取插槽数据。 （9）mitt.js 适用于任意组件通信 Vue3 中移除了 $on，$off等方法，所以 EventBus 不再使用，相应的替换方案就是 mitt.js Vue3和vue2 全局组件和局部组件注册的方式？ Vue2：Vue.component() Vue3：app.component() 什么是动态组件？动态组件的钩子如何执行？ 让多个组件使用同一个挂载点，并动态切换，这就是动态组件 简单的说，动态组件就是将几个组件放在一个挂载点下，这个挂载点就是标签，其需要绑定 is 属性，属性值为父组件中的变量，变量对应的值为要挂载的组件的组件名，然后根据父组件里某个变量来动态显示哪个，也可以都不显示。 缓存 &lt;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。 可以将动态组件放到组件内对动态组件进行缓存，这样动态组件进行切换的时候，就不会每次都重新创建了。 Keep-alive的作用？使用keep-alive的组件如何监控组件切换？ keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性： 一般结合路由和动态组件一起使用，用于缓存组件； 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。 父组件如何监听子组件的生命周期？ 比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现： //&nbsp;Parent.vue &lt;Child&nbsp;@mounted=\"doSomething\"/&gt; &nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;Child.vue mounted()&nbsp;&#123; &nbsp;&nbsp;this.$emit(\"mounted\"); &#125; 复制代码 以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示： //&nbsp;&nbsp;Parent.vue &lt;Child&nbsp;@hook:mounted=\"doSomething\"&nbsp;&gt;&lt;/Child&gt; doSomething()&amp;nbsp;&#123;&amp;nbsp;&amp;nbsp;&amp;nbsp;console.log(‘父组件监听到&amp;nbsp;mounted&amp;nbsp;钩子函数&amp;nbsp;…’);&#125;,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#x2F;&#x2F;&amp;nbsp;&amp;nbsp;Child.vuemounted()&#123;&amp;nbsp;&amp;nbsp;&amp;nbsp;console.log(‘子组件触发&amp;nbsp;mounted&amp;nbsp;钩子函数&amp;nbsp;…’);&#125;,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#x2F;&#x2F;&amp;nbsp;以上输出顺序为：&#x2F;&#x2F;&amp;nbsp;子组件触发&amp;nbsp;mounted&amp;nbsp;钩子函数&amp;nbsp;…&#x2F;&#x2F;&amp;nbsp;父组件监听到&amp;nbsp;mounted&amp;nbsp;钩子函数&amp;nbsp;…&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;复制代码 当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。 原理相关Vue初始化时都做了什么？ 【源码学习】Vue 初始化过程 (附思维导图) 第一部分 ⭐ 每个 vue 实例都有一个 _uid，并且是依次递增的，确保唯一性。 ⭐ vue 实例不应该是一个响应式的，做个标记。 第二部分 ⭐ 如果是子组件,将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率。 ⭐ 如果是根组件，对 options 进行合并，vue 会将相关的属性和方法都统一放到 vm.$options 中。vm.$options 的属性来自两个方面，一个是 Vue 的构造函数 vm.constructor 预先定义的，一个是 new Vue 时传入的入参对象。 第三部分 ⭐ initProxy / vm._renderProxy 在非生产环境下执行了 initProxy 函数,参数是实例;在生产环境下设置了实例的 _renderProxy 属性为实例自身。 ⭐ 设置了实例的 _self 属性为实例自身。 ⭐ initLifecycle 初始化组件实例关系属性 , 比如 $parent、$children、$root、$refs 等 （不是组件生命周期 mounted , created...） ⭐ initEvents 初始化自定义事件。 ⭐ initRender 初始化插槽 , 获取 this.slots , 定义 this._c , 也就是 createElement 方法 , 平时使用的 h 函数。 ⭐ callHook 执行 beforeCreate 生命周期函数。 ⭐ initInjections 初始化 inject 选项 ⭐ initState 响应式原理的核心 , 处理 props、methods、computed、data、watch 等。 ⭐ initProvide 解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上。 ⭐ callHook 执行 created 生命周期函数。 第四部分 ⭐ 如果有 el 属性，则调用 vm.$mount 方法挂载 vm ，挂载的目标就是把模板渲染成最终的 DOM。 ⭐ 不存在 el 的时候不挂载 , 需要手动挂载。 数据响应式的原理 Vue.js 是采用 数据劫持 结合 发布者-订阅者模式 的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤： 使用 observe 对需要响应式的数据进行递归，将对像的所有属性及其子属性，都加上 setter 和 getter 这样的话，给这个对象的某个属性赋值的时候，就会触发 setter，那么就能监听到了数据变化。 compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。 Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是: 在自身实例化时往属性订阅器(dep)里面添加自己 自身必须有一个 update() 方法 待属性变动触发 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，完成视图更新。 总结：通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到一个数据响应式的效果。 使用 Object.defineProperty() 来进行数据劫持有什么缺点？ 无法劫持以下操作 给对象新增属性 给对象删除属性 大部分的操作数组 Vue 框架怎么实现对象和数组的监听？ Vue 框架是通过 遍历数组 和 递归遍历对象，从而达到利用 Object.defineProperty() 对对象和数组的部分方法的操作进行监听。 Vue 中给 data 中的对象属性添加一个新的属性或删除一个属性时会发生什么？如何解决？ 什么都不会发生，因为 Object.defineProperty() 监听不到这类变化。 可以使用 vm.$set 和 Vue.set 方法去添加一个属性。 可以使用 vm.$delete 和 Vue.delete 方法去删除一个属性。 如何解决索引赋值或者修改数组长度无法改变视图？ 由于 Vue 只改写了 7 种修改数组的方法，所以 Vue 不能检测到以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 为了解决第一个问题，Vue 提供了以下操作方法： //&nbsp;Vue.set Vue.set(vm.items,&nbsp;indexOfItem,&nbsp;newValue) //&nbsp;vm.$set，Vue.set的一个别名 vm.$set(vm.items,&nbsp;indexOfItem,&nbsp;newValue) //&nbsp;Array.prototype.splice vm.items.splice(indexOfItem,&nbsp;1,&nbsp;newValue) 复制代码 为了解决第二个问题，Vue 提供了以下操作方法： //&nbsp;Array.prototype.splice vm.items.splice(newLength) 复制代码 数组的响应式是怎么实现的？ 择对 7 种数组（push,shift,pop,splice,unshift,sort,reverse）方法进行重写 所以在 Vue 中修改数组的索引和长度是无法监控到的。需要通过以上 7 种变异方法修改数组才会触发数组对应的 watcher 进行更新 //&nbsp;src/obserber/array.js\\ //&nbsp;先保留数组原型\\ const&nbsp;arrayProto&nbsp;=&nbsp;Array.prototype;\\ //&nbsp;然后将arrayMethods继承自数组原型\\ //&nbsp;这里是面向切片编程思想（AOP）--不破坏封装的前提下，动态的扩展功能\\ export&nbsp;const&nbsp;arrayMethods&nbsp;=&nbsp;Object.create(arrayProto);\\ let&nbsp;methodsToPatch&nbsp;=&nbsp;[\\ &nbsp;&nbsp;\"push\",\\ &nbsp;&nbsp;\"pop\",\\ &nbsp;&nbsp;\"shift\",\\ &nbsp;&nbsp;\"unshift\",\\ &nbsp;&nbsp;\"splice\",\\ &nbsp;&nbsp;\"reverse\",\\ &nbsp;&nbsp;\"sort\",\\ ];\\ methodsToPatch.forEach((method)&nbsp;=&gt;&nbsp;&#123;\\ &nbsp;&nbsp;arrayMethods[method]&nbsp;=&nbsp;function&nbsp;(...args)&nbsp;&#123;\\ &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;这里保留原型方法的执行结果\\ &nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;result&nbsp;=&nbsp;arrayProto[method].apply(this,&nbsp;args);\\ &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;这句话是关键\\ &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this代表的就是数据本身&nbsp;比如数据是&#123;a:[1,2,3]&#125;&nbsp;那么我们使用a.push(4)&nbsp;&nbsp;this就是a&nbsp;&nbsp;ob就是a.__ob__&nbsp;这个属性就是上段代码增加的&nbsp;代表的是该数据已经被响应式观察过了指向Observer实例\\ &nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ob&nbsp;=&nbsp;this.__ob__;\\ \\ &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;这里的标志就是代表数组有新增操作\\ &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;inserted;\\ &nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(method)&nbsp;&#123;\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;\"push\":\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;\"unshift\":\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inserted&nbsp;=&nbsp;args;\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;\"splice\":\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inserted&nbsp;=&nbsp;args.slice(2);\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;\\ &nbsp;&nbsp;&nbsp;&nbsp;&#125;\\ &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果有新增的元素&nbsp;inserted是一个数组&nbsp;调用Observer实例的observeArray对数组每一项进行观测\\ &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(inserted)&nbsp;ob.observeArray(inserted);\\ &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;之后咱们还可以在这里检测到数组改变了之后从而触发视图更新的操作--后续源码会揭晓\\ &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;\\ &nbsp;&nbsp;&#125;;\\ &#125;); 复制代码 $nextTick的原理是什么？ nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法。 简单的理解是：当数据更新了，在 dom 中渲染后， 自动执行该函数。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，Vue 是异步执行 DOM 更新的。created 钩子函数进行的 DOM 操作一定要放在Vue.nextTick() 的回调函数中，原因是在函数执行的时候 DOM 其实并未进行任何渲染。常用的场景是在进行获取数据后，需要对新视图进行下一步操作或者其他操作时，发现获取不到 dom。因为赋值操作只完成了数据模型的改变并没有完成视图更新。 &nbsp;&nbsp;&nbsp;&nbsp;有一个 timerFunc 这个函数用来执行 callbacks 里存储的所有回调函数 &nbsp;&nbsp;&nbsp;&nbsp;先判断是否原生支持 promise，如果支持，则利用 promise 来触发执行回调函数； &nbsp;&nbsp;&nbsp;&nbsp;否则，如果支持 MutationObserver，则实例化一个观察者对象，观察文本节点发生变化时，触发执行所有回调函数。 &nbsp;&nbsp;&nbsp;如果都不支持，则利用 setTimeout 设置延时为 0。 列表循环时 key 有什么作用？ key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有 4 种比较方式：newStartIndex 和 oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了 key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。 所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速，因为带 key 就不是就地复用了，在 sameNode 函数&nbsp;a.key === b.key&nbsp;对比中可以避免就地复用的情况。利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下： function&nbsp;createKeyToOldIdx&nbsp;(children,&nbsp;beginIdx,&nbsp;endIdx)&nbsp;&#123; &nbsp;&nbsp;let&nbsp;i,&nbsp;key &nbsp;&nbsp;const&nbsp;map&nbsp;=&nbsp;&#123;&#125; &nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;beginIdx;&nbsp;i&nbsp;&lt;=&nbsp;endIdx;&nbsp;++i)&nbsp;&#123; &nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;children[i].key &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(isDef(key))&nbsp;map[key]&nbsp;=&nbsp;i &nbsp;&nbsp;&#125; &nbsp;&nbsp;return&nbsp;map &#125; 复制代码 为什么不建议用index作为key? 使用 index 作为 key 和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2... 这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。 v-if、v-show、v-html 的原理 v-if 会调用 addIfCondition 方法，生成 vnode 的时候会忽略对应节点，render 的时候就不会渲染； v-show 会生成 vnode，render 的时候也会渲染成真实节点，只是在 render 过程中会在节点的属性中修改 show 属性值，也就是常说的 display； v-html 会先移除节点下的所有节点，设置 innerHTML 为 v-html 的值。 Vue中封装的数组方法有哪些，其如何实现页面更新 数组就是使用 object.defineProperty 重新定义数组的每一项，那能引起数组变化的方法我们都是知道的， pop 、 push 、 shift 、 unshift 、 splice 、 sort 、 reverse 这七种，只要这些方法执行改了数组内容，我就更新内容就好了，是不是很好理解。 是用来函数劫持的方式，重写了数组方法，具体呢就是更改了数组的原型，更改成自己的，用户调数组的一些方法的时候，走的就是自己的方法，然后通知视图去更新。 数组里每一项可能是对象，那么我就是会对数组的每一项进行观测，（且只有数组里的对象才能进行观测，观测过的也不会进行观测） vue3：改用 proxy ，可直接监听对象数组的变化。 Vue模板渲染的原理是什么？ vue 中的模板 template 无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的 HTML 语法，所有需要将 template 转化成一个 JavaScript 函数，这样浏览器就可以执行这一个函数并渲染出对应的 HTML 元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。 模板编译又分三个阶段，解析 parse，优化 optimize，生成 generate，最终生成可执行函数 render。 parse阶段：使用大量的正则表达式对 template 字符串进行解析，将标签、指令、属性等转化为抽象语法树 AST。 optimize阶段：遍历 AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行 diff 比较时，直接跳过这一些静态节点，优化 runtime 的性能。 generate阶段：将最终的 AST 转化为 render 函数字符串。 说一下什么是Virtual DOM Virtual DOM 是 DOM 节点在 JavaScript 中的一种抽象数据结构，之所以需要虚拟 DOM，是因为浏览器中操作 DOM 的代价比较昂贵，频繁操作 DOM 会产生性能问题。虚拟 DOM 的作用是在每一次响应式数据发生变化引起页面重渲染时，Vue 对比更新前后的虚拟 DOM，匹配找出尽可能少的需要更新的真实 DOM，从而达到提升性能的目的。 Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？ Vue 是异步执行 DOM 更新。 只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。 如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。 然后，在下一个的事件循环&nbsp;tick&nbsp;中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。 例如，当你设置 vm.someData = 'new value' ，该组件不会立即重新渲染。 当刷新队列时，组件会在事件循环队列清空时的下一个&nbsp;tick&nbsp;更新。 多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。 虽然 Vue.js 通常鼓励开发人员沿着 “数据驱动” 的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。 Vue.mixin 的使用场景和原理 在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立，可以通过 Vue 的 mixin 功能抽离公共的业务逻辑，原理类似“对象的继承”，当组件初始化时会调用 mergeOptions 方法进行合并，采用策略模式针对不同的属性进行合并。当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。 Vue.extend 作用和原理 其实就是一个子类构造器 ，是 Vue 组件的核心 api 实现思路就是使用原型继承的方法返回了 Vue 的子类 并且利用 mergeOptions 把传入组件的 options 和父类的 options 进行了合并。 Vue 事件绑定原理 原生事件绑定是通过 addEventListener 绑定给真实元素的，组件事件绑定是通过 Vue 自定义的 $on 实现的。如果要在组件上使用原生事件，需要加 .native 修饰符，这样就相当于在父组件中把子组件当做普通 html 标签，然后加上原生事件。 on、emit 是基于发布订阅模式的，维护一个事件中心，on 的时候将事件按名称存在事件中心里，称之为订阅者，然后 emit 将对应的事件进行发布，去执行事件中心里的对应的监听器。 虚拟 DOM 实现原理？ 虚拟 DOM 的实现原理主要包括以下 3 部分： 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象； diff 算法 — 比较两棵虚拟 DOM 树的差异； pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。 虚拟 dom 和真实 dom 的区别 虚拟 DOM 不会进行排版与重绘操作&nbsp; 虚拟 DOM 就是把真实 DOM 转换为 Javascript 代码 虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后并在真实 DOM 中进行排版与重绘，减少过多 DOM 节点排版与重绘损耗 生态相关vue-router 路由模式有几种？ vue-router 有 3 种路由模式：hash、history、abstract： hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器； history : 依赖 HTML5 History API 和服务器配置。 abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式. 路由的hash和history模式的区别 （1）hash 模式的实现原理 早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 #search： https://www.word.com#search 复制代码 hash 路由模式的实现主要是基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送； hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制 hash 的切换； 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值； 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。 （2）history 模式的实现原理 HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示： window.history.pushState(null,&nbsp;null,&nbsp;path); window.history.replaceState(null,&nbsp;null,&nbsp;path); 复制代码 history 路由模式的实现主要基于存在下面几个特性： pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ； 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）； history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。 如何获取页面的hash变化 监听 $route 对象 // 监听,当路由发生变化的时候执行 watch: &#123; $route: &#123; handler: function(val, oldVal)&#123; console.log(val); &#125;, // 深度观察监听 deep: true &#125; 复制代码 route 和 router 的区别 $router&nbsp;是 VueRouter 的实例，在 script 标签中想要导航到不同的 URL,使用&nbsp;$router.push&nbsp;方法。返回上一个历史 history 用&nbsp;$router.to(-1) $route&nbsp;为当前 router 跳转对象。里面可以获取当前路由的 name,path,query,parmas 等。 如何定义动态路由？如何获取传过来的动态参数？ 可以通过query，param两种方式 区别：query通过url传参，刷新页面还在；params属性页面不在 params的类型： 配置路由格式: /router/:id 传递的方式：在 path 后面跟上对应的值 传递后形成的路径：/router/123 通过 $route.params.id 获取传递的值 query 的类类型 配置路由格式 :/router 也就是普通配置 传递的方式:对象中使用 query 的 key 作为传递方式 传递后形成的路径 :/route?id=123 通过 $route.query 获取传递的值 Vue-router 导航守卫有哪些 【面试题解】vue-router有几种钩子函数？具体是什么及执行流程是怎样的？ Vue-router跳转和location.href有什么区别 使用&nbsp;location.href= /url&nbsp;来跳转，简单方便，但是刷新了页面； 使用&nbsp;history.pushState( /url )&nbsp;，无刷新页面，静态跳转； 引进 router ，然后使用&nbsp;router.push( /url )&nbsp;来跳转，使用了&nbsp;diff&nbsp;算法，实现了按需加载，减少了 dom 的消耗。 其实使用 router 跳转和使用&nbsp;history.pushState()&nbsp;没什么差别的，因为 vue-router 就是用了&nbsp;history.pushState()&nbsp;，尤其是在 history 模式下。 params和query的区别 用法：query 要用 path 来引入，params 要用 name 来引入，接收参数都是类似的，分别是&nbsp;this.$route.query.name&nbsp;和&nbsp;this.$route.params.name&nbsp;。 url 地址显示：query 更加类似于我们 ajax 中 get 传参，params 则类似于 post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示。 注意点：query 刷新不会丢失 query 里面的数据， params 刷新会丢失 params 里面的数据。 Vuex 的原理 Vue 组件会触发 （dispatch）一些事件或动作，也就是 Actions; 在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中; 然后 Mutations 就去改变 State 中的数据; 当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。 Vuex有哪几种属性 有五种，分别 State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。 Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。 Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。 Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。 Vuex和单纯的全局对象有什么区别？ Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 mutation。 Vuex中action和mutation的区别 Mutation 专注于修改 State，理论上是修改 State 的唯一途径；Action 业务代码、异步请求。 Mutation：必须同步执行；Action：可以异步，但不能直接操作 State。 在视图更新时，先触发 actions，actions 再触发 mutation mutation 的参数是 state，它包含 store 中的数据；action 的参数是 context，它是 state 的父级，包含 state、getters等。 为什么 Vuex 的 mutation 中不能做异步操作？ Vuex 中所有的状态更新的唯一途径都是 mutation，异步操作通过 Action 来提交 mutation 实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。 每个 mutation 执行完成后都会对应到一个新的状态变更，这样 devtools 就可以打个快照存下来。如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。 Vuex 和 localStorage 的区别 （1）最重要的区别 vuex 存储在内存中 localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON 的 stringify 和 parse 方法进行处理。 读取内存比读取硬盘速度要快 （2）应用场景 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex 用于组件之间的传值。 localstorage 是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。 Vuex 能做到数据的响应式，localstorage 不能 （3）永久性 刷新页面时 vuex 存储的值会丢失，localstorage 不会，对于不变的数据可以用 localstorage 可以代替 vuex。 Vuex的严格模式是什么,有什么作用，如何开启？ 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 在 Vuex.Store 构造器选项中开启,如下 const store = new Vuex.Store(&#123; strict:true, &#125;) 复制代码 如何在组件中批量使用Vuex的getter属性 使用 mapGetters 辅助函数, 利用对象展开运算符将 getter 混入 computed 对象中 import &#123;mapGetters&#125; from 'vuex' export default&#123; computed:&#123; ...mapGetters(['total','discountTotal']) &#125; &#125; 复制代码 如何在组件中重复使用Vuex的mutation 使用 mapMutations 辅助函数,在组件中这么使用 import &#123; mapMutations &#125; from 'vuex' methods:&#123; ...mapMutations(&#123; setNumber:'SET_NUMBER', &#125;) &#125; 复制代码 Vuex 页面刷新数据丢失怎么解决 在 created 周期中读取 sessionstorage 中的数据存储在 store 中，此时用 vuex.store 的 replaceState 方法，替换 store 的根状态 在 beforeunload 方法中将 store.state 存储到 sessionstorage 中。 export default &#123; name: 'App', created() &#123; //在页面加载时读取sessionStorage里的状态信息 if (sessionStorage.getItem(\"store\")) &#123; this.$store.replaceState(Object.assign(&#123;&#125;, this.$store.state, JSON.parse(sessionStorage.getItem(\"store\")))) &#125; //在页面刷新时将vuex里的信息保存到sessionStorage里 window.addEventListener(\"beforeunload\", () =&gt; &#123; sessionStorage.setItem(\"store\", JSON.stringify(this.$store.state)) &#125;) &#125; &#125; 复制代码 3.0相关Vue3.0 有什么更新 Vue3 的大多都在这里了。 【初学者笔记】整理的一些Vue3知识点 Vue3.0 defineProperty和proxy的区别 Vue3.x 改用 Proxy 替代 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化，并且有多达 13 种拦截方法。 Proxy 与 Object.defineProperty 优劣对比 Proxy 的优势如下: Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化； Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改； Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利； Object.defineProperty 的优势如下: 兼容性好，支持 IE9。 Vue 3.0 生命周期有哪些变化？ 注意:3.0中的生命周期钩子要比2.X中相同生命周期的钩子要快 Composition API还新增了以下调试钩子函数：但是不怎么常用 onRenderTracked onRenderTriggered Vue 3.0 自定义指令有哪些变化？ 先看看Vue2自定义指令的钩子 bind：当指令绑定在对应元素时触发。只会触发一次。 inserted：当对应元素被插入到 DOM 的父元素时触发。 update：当元素更新时，这个钩子会被触发（此时元素的后代元素还没有触发更新）。 componentUpdated：当整个组件（包括子组件）完成更新后，这个钩子触发。 unbind：当指令被从元素上移除时，这个钩子会被触发。也只触发一次。 在 Vue3 中，官方为了更有助于代码的可读性和风格统一，把自定义指令的钩子名称改的更像是组件生命周期，尽管他们是两回事 bind =&gt; beforeMount inserted =&gt; mounted beforeUpdate: 新的钩子，会在元素自身更新前触发 update =&gt; 移除！ componentUpdated =&gt; updated beforeUnmount: 新的钩子，当元素自身被卸载前触发 unbind =&gt; unmounted 后语最后祝大家在新的一年里，都能找到满意的工作，升职加薪，赚的盆满钵满！ 作者：一尾流莺链接：https://juejin.cn/post/7064368176846340132来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"分类","slug":"分类","permalink":"http://example.com/categories/%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"标签","slug":"标签","permalink":"http://example.com/tags/%E6%A0%87%E7%AD%BE/"}],"author":"作者"},{"title":"scss基础用法学习","slug":"scss基础用法学习","date":"2022-11-01T02:26:49.000Z","updated":"2022-11-01T02:26:49.000Z","comments":true,"path":"2022/11/01/scss基础用法学习/","link":"","permalink":"http://example.com/2022/11/01/scss%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"SCSS 教程，基础，日常用法 本文是以自己的理解起的结构，要看详细的帮助文档，参阅这里：https://sass-lang.com/documentation/ 文中用到的方法等，在线实例：https://kylebing.cn/test/scss/ 延伸阅读： 如何在 JetBrains 系列软件中使用 scss : https://blog.csdn.net/KimBing/article/details/100532939关于 scss 的相关配置：https://kylebing.blog.csdn.net/article/details/106015111 你需要了解的: less | sass | scss 都是什么less 和 scss 是两种 css 预编译语言，就是说通过 less 或者 scss 写的代码最终都会被编译成 css 再使用。其目的是为了更快、更结构的编写 css 文件，都能使用 变量、逻辑运算、判断、颜色方法、数学方法等等。scss 比 less 语法更规范些，现在主流用 scss。我也是从 less 开始的，后来转为了 scss。如果你现在在用 less，我建议你改成 scss，相比之下， 总感觉 less 不太严谨，在做大项目的时候会比较吃力。 scss sass 是同一种东西：只是有以下不同： scss 需要大括号{}和分号; sass 什么都不用直接裸奔，通过缩进来区分代码等级，像 yaml 语言 使用 scss 之前你需要准备的如果需要即时由 scss 生成 css 文件，最好用 JetBrains 系列软件（webStorm phpStorm IDEA等），里面添加对于 scss 的 File Watcher 即可，在每次scss 文件改变的时候，程序都会自动将 scss 编译到 css。 在 vue 中如何使用 scss，请跳转至本文第八条 关于如何添加 scss 支持，看这里： https://blog.csdn.net/KimBing/article/details/100532939更详细的配置，看这里：https://blog.csdn.net/KimBing/article/details/106015111 看个小例子写一个 .btn 类并支持 :hover :active 样式 css 123.btn &#123; &#125;.btn:hover&#123; &#125;.btn:active&#123; &#125; scss 123456789.btn&#123;// 此处为 btn 初始样式 &amp;:hover&#123; // hover 样式 &#125; &amp;:active&#123; // active 样式 &#125;&#125; &amp; 都代指父类上面这个例子中的 &amp; 代指 .btn可以看出 scss 的结构要比 css 清晰，并且写的也更少。下面的 scss 会生成上面的 css。而这还只是皮毛，保证你用过 scss 之后就不再想用 css 写样式了。 一、变量变量是以 $ 开头的，可以是颜色，长度，数值等等，还可以是带单位的 12px。带单位的变量使用中跟普通数值变量一样，比如： 1234$padding-normal: 10px;.container&#123; padding: $padding-normal * 2&#125; 123.container&#123; padding: 20px;&#125; 像 js 的变量一样，scss 的变量也是有作用域的，也就是说内部声明的变量是无法在外面使用的。 如果想让内部的变量在外部可访问，需要在变量值后面添加 !global 声明。 （还可以通过添加 !default 给变量设置默认值，这个在写一个样式库的时候比较实用，避免别人在没有给变量赋值之前使用） 1$变量名: 变量值 123456789// Colors$red: #CD594B !global;$yellow: #F8CE5E;$green: #4B9E65;$yellow: #5A8DEE;// Unites$btn-padding: 4px;$btn-lineheight: 26px; 实际使用中： scss 12345.btn-success &#123; background-color: $green; line-height: $btn-lineheight; color: #fff;&#125; 生成 css 123456.btn-success &#123; background-color: #4B9E65; line-height: 26px; color: #fff;&#125; 字符串拼接，字符串嵌入将变量直接嵌入字符串，需要用 #{ 变量 } （类似 ES6 中模板字符串中的 ${ 变量 }） 其实 #{} 中是可以插入任意东西的，这里只用到了插入变量，还可以插入方法等等，高级用法。具体可以看下面关于 @for 的章节 scss 12345$father-class: &quot;card-list&quot;;.#&#123;$father-class&#125;-item&#123; padding: 20px;&#125; css 123.card-list-item&#123; padding: 20px;&#125; 二、导入文件 @import通过 @import 可以把多个文件结合到一起有了这个功能，就可以根据不同功能模块对 scss 文件进行拆分，使其更结构化。比如，可以分成：变量类，按钮类，列表类，字体类，排版类等等。 拆分成多个文件的时候，scss 环境下，以 _开头命名的文件，不会预编译成 .css 文件而 less 则没有这个忽略 _开头文件的功能 比如，我一个项目的 css 结构是这样的：以 _ 开头的都是整个项目的 css 的结构部分，像底部按键、表单、按钮、通用方法等。 _variables.scss 12$bg-btn: #ddd;$color-btn: #444; btn.scss 123456789@import &quot;variables&quot;;.btn&#123; display: inline-block; padding: 3px 6px; background-color: $bg-btn; color: $color-btn;&#125; 生成 css 123456.btn&#123; display: inline-block; padding: 3px 6px; background-color: #ddd; color: #444;&#125; 在一般的大型项目中，如 bootstrap，scss 文件的目录是这样的：项目所有的负责各部件的 scss 文件被盛放到一个文件夹中，然后通过一个 _mixin.scss 文件来集中引用，在主文件中只需要引入 _minxin.scss 一个文件即可，像下面这样的结构。 1234567891011121314151617181920css/├── _mixin.scss├── _reset.scss├── _utility.scss├── _variables.scss├── diary.css├── diary.css.map├── diary.scss└── mixins ├── _category.scss ├── _detail.scss ├── _edit.scss ├── _index.scss ├── _loading.scss ├── _long.scss ├── _menu.scss ├── _navbar.scss ├── _regist.scss ├── _toast.scss └── _weather.scss _minxin.scss 内容 1234567891011@import &quot;./mixins/detail&quot;;@import &quot;./mixins/edit&quot;;@import &quot;./mixins/index&quot;;@import &quot;./mixins/loading&quot;;@import &quot;./mixins/menu&quot;;@import &quot;./mixins/navbar&quot;;@import &quot;./mixins/regist&quot;;@import &quot;./mixins/toast&quot;;@import &quot;./mixins/long&quot;;@import &quot;./mixins/category&quot;;@import &quot;./mixins/weather&quot;; diary.scss 项目主样式文件 1234567891011121314151617@import &quot;reset&quot;;@import &quot;utility&quot;;@import &quot;variables&quot;;@import &quot;mixin&quot;; // 只需要引入一个即可.body-normal&#123;background-color: $bg-light;&#125;.body-white&#123;background-color: white;&#125;// FRAMEbody&#123; position: relative; @extend .body-normal;&#125;.container&#123; padding: 45px 0; width: 100%;&#125; 引入 css 文件：比如有一个 animate.css 的 css 文件需要引入到 scss 文件中，只需要这样 1@import &quot;animate&quot; 优先级这里需要注意一下优先级，最后引入的文件拥有比前面引入的同级样式更高的优先级。这个是 css 的基础知识。比如你需要给你的项目添加一个暗黑样式来适配暗黑样式，一般情况下，这个文件需要在最后引入，除非你的暗黑样式里全用了 !important 三、@mixin，@include1. @mixin @include这两个最常用的指令，通过 @mixin 定义一个类或方法，在其它地方通过 @include 引用这个方法或类，跟 js 十分相似。 如果是方法，还可以定义默认值，也就是说可以某些时候，可以传部分参数。 直接看例子 scss 12345678910111213141516// @mixin 如果没有调用，不会被渲染@mixin rounded($conor: 5px)&#123; // 定义 mixin 并设置默认值 5px -webkit-border-radius: $conor; -moz-border-radius: $conor; border-radius: $conor;&#125;.btn-rounded&#123; @include rounded(); // 这里引用上面的 mixin，默认值 5px&#125;.btn-big-rounded&#123; @include rounded(10px); // 这里引用上面的 mixin，并设置值 10px&#125; 生成 css 12345678910.btn-rounded&#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px;&#125;.btn-big-rounded&#123; -webkit-border-radius: 10px; -moz-border-radius: 10px; border-radius: 10px;&#125; 扩展 ： mixin 想输入多个参数的时候 参数可以这样写 123456789@mixin box-shadow($shadow...)&#123; -webkit-box-shadow: $shadow; -moz-box-shadow: $shadow; box-shadow: $shadow;&#125;.btn&#123; @include box-shadow(1px 1px 3px rgba(0,0,0,0.2), 1px -1px 13px rgba(0,0,0,0.2))&#125; 可以看到，这个在写适配不同浏览器专有属性的时候十分方便：比如 border-radius transition transform box-shadow 等等 2. @extend 继承有些时候，需要写的某个类里，包含另一个类的所有声明。就可以直接拿来使用。 如： 警告按钮，包含所有警告颜色类的内容。 scss 12345678910111213141516.danger&#123; background-color: #FF3B30;&#125;.round&#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px;&#125;.btn&#123; display: inline-block; padding: 3px 6px;&#125;.btn-danger&#123; @extend .danger, .round, .btn;&#125; css 123456789101112.danger, .btn-danger &#123; background-color: #FF3B30;&#125;.round, .btn-danger &#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px;&#125;.btn, .btn-danger &#123; display: inline-block; padding: 3px 6px;&#125; @extend 注意事项：不能继承 @extend .danger.text 这种连续组合的类，应该写为 @extend .danger, .text 四、逻辑运算 @if @else, @each, @for1. @if @else没什么说的，就是 if else 《官方文档：if else》 SCSS 1234567@if $name == normal &#123; // 判断 $name 是否为 &#x27;normal&#x27; color: #333; // 如果是，内部文字颜色为 #333 border: 1px solid darken($color, 20%);&#125; @else &#123; color: white; border: 1px solid darken($color, 5%);&#125; 2. @each跟 js 中的 Array.forEach(item &#x3D;&gt; {}) 一样，遍历变量所存在的所有数据。比如下面的例子，会遍历 $btn-styles 中的三个字符串，这里就用到了上面提到的将变量内容作为字符串内容的 #{变量名} 12345678$btn-styles: &quot;normal&quot;, &quot;primary&quot;, &quot;danger&quot;;@each $type in $btn-styles &#123; .btn-#&#123;$type&#125;&#123; background-color: white; &#125;&#125; CSS 123.btn-normal &#123; background-color: white; &#125;.btn-primary &#123; background-color: white; &#125;.btn-danger &#123; background-color: white; &#125; 3. @for for 用于基于数字的遍历，有两种使用方法 for $i from 1 to 10 从 1 到 10，不包含 10for $i from 1 through 10 从 1 到 10，包含 10举个最常用的例子，生成 pb-1 pb-2… pb-8 SCSS 12345@for $gap from 1 through 8 &#123; .pb-#&#123;$gap&#125; &#123; padding-bottom: 10px * $gap; &#125;&#125; CSS 12345678.pb-1 &#123; padding-bottom: 10px; &#125;.pb-2 &#123; padding-bottom: 20px; &#125;.pb-3 &#123; padding-bottom: 30px; &#125;.pb-4 &#123; padding-bottom: 40px; &#125;.pb-5 &#123; padding-bottom: 50px; &#125;.pb-6 &#123; padding-bottom: 60px; &#125;.pb-7 &#123; padding-bottom: 70px; &#125;.pb-8 &#123; padding-bottom: 80px; &#125; 然后你就可以再进一步，生成 mt mb ml mr pt pb pl pr 这些 css 工具类 SCSS 1234567891011121314$timer: 10px;@for $item from 1 through 8 &#123; .mt-#&#123;$item&#125;&#123; margin-top: $timer * $item !important;&#125; .mb-#&#123;$item&#125;&#123; margin-bottom: $timer * $item !important;&#125; .ml-#&#123;$item&#125;&#123; margin-left: $timer * $item !important;&#125; .mr-#&#123;$item&#125;&#123; margin-right: $timer * $item !important;&#125; .m-#&#123;$item&#125; &#123; margin: $timer * $item !important;&#125; .pt-#&#123;$item&#125;&#123; padding-top: $timer * $item !important;&#125; .pb-#&#123;$item&#125;&#123; padding-bottom: $timer * $item !important;&#125; .pl-#&#123;$item&#125;&#123; padding-left: $timer * $item !important;&#125; .pr-#&#123;$item&#125;&#123; padding-right: $timer * $item !important;&#125; .p-#&#123;$item&#125; &#123; padding: $timer * $item !important;&#125;&#125; 生成 CSS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980.mt-1 &#123; margin-top : 10px!important&#125;.mb-1 &#123; margin-bottom : 10px!important&#125;.ml-1 &#123; margin-left : 10px!important&#125;.mr-1 &#123; margin-right : 10px!important&#125;.m-1 &#123; margin : 10px!important&#125;.pt-1 &#123; padding-top : 10px!important&#125;.pb-1 &#123; padding-bottom : 10px!important&#125;.pl-1 &#123; padding-left : 10px!important&#125;.pr-1 &#123; padding-right : 10px!important&#125;.p-1 &#123; padding : 10px!important&#125;.mt-2 &#123; margin-top : 20px!important&#125;.mb-2 &#123; margin-bottom : 20px!important&#125;.ml-2 &#123; margin-left : 20px!important&#125;.mr-2 &#123; margin-right : 20px!important&#125;.m-2 &#123; margin : 20px!important&#125;.pt-2 &#123; padding-top : 20px!important&#125;.pb-2 &#123; padding-bottom : 20px!important&#125;.pl-2 &#123; padding-left : 20px!important&#125;.pr-2 &#123; padding-right : 20px!important&#125;.p-2 &#123; padding : 20px!important&#125;.mt-3 &#123; margin-top : 30px!important&#125;.mb-3 &#123; margin-bottom : 30px!important&#125;.ml-3 &#123; margin-left : 30px!important&#125;.mr-3 &#123; margin-right : 30px!important&#125;.m-3 &#123; margin : 30px!important&#125;.pt-3 &#123; padding-top : 30px!important&#125;.pb-3 &#123; padding-bottom : 30px!important&#125;.pl-3 &#123; padding-left : 30px!important&#125;.pr-3 &#123; padding-right : 30px!important&#125;.p-3 &#123; padding : 30px!important&#125;.mt-4 &#123; margin-top : 40px!important&#125;.mb-4 &#123; margin-bottom : 40px!important&#125;.ml-4 &#123; margin-left : 40px!important&#125;.mr-4 &#123; margin-right : 40px!important&#125;.m-4 &#123; margin : 40px!important&#125;.pt-4 &#123; padding-top : 40px!important&#125;.pb-4 &#123; padding-bottom : 40px!important&#125;.pl-4 &#123; padding-left : 40px!important&#125;.pr-4 &#123; padding-right : 40px!important&#125;.p-4 &#123; padding : 40px!important&#125;.mt-5 &#123; margin-top : 50px!important&#125;.mb-5 &#123; margin-bottom : 50px!important&#125;.ml-5 &#123; margin-left : 50px!important&#125;.mr-5 &#123; margin-right : 50px!important&#125;.m-5 &#123; margin : 50px!important&#125;.pt-5 &#123; padding-top : 50px!important&#125;.pb-5 &#123; padding-bottom : 50px!important&#125;.pl-5 &#123; padding-left : 50px!important&#125;.pr-5 &#123; padding-right : 50px!important&#125;.p-5 &#123; padding : 50px!important&#125;.mt-6 &#123; margin-top : 60px!important&#125;.mb-6 &#123; margin-bottom : 60px!important&#125;.ml-6 &#123; margin-left : 60px!important&#125;.mr-6 &#123; margin-right : 60px!important&#125;.m-6 &#123; margin : 60px!important&#125;.pt-6 &#123; padding-top : 60px!important&#125;.pb-6 &#123; padding-bottom : 60px!important&#125;.pl-6 &#123; padding-left : 60px!important&#125;.pr-6 &#123; padding-right : 60px!important&#125;.p-6 &#123; padding : 60px!important&#125;.mt-7 &#123; margin-top : 70px!important&#125;.mb-7 &#123; margin-bottom : 70px!important&#125;.ml-7 &#123; margin-left : 70px!important&#125;.mr-7 &#123; margin-right : 70px!important&#125;.m-7 &#123; margin : 70px!important&#125;.pt-7 &#123; padding-top : 70px!important&#125;.pb-7 &#123; padding-bottom : 70px!important&#125;.pl-7 &#123; padding-left : 70px!important&#125;.pr-7 &#123; padding-right : 70px!important&#125;.p-7 &#123; padding : 70px!important&#125;.mt-8 &#123; margin-top : 80px!important&#125;.mb-8 &#123; margin-bottom : 80px!important&#125;.ml-8 &#123; margin-left : 80px!important&#125;.mr-8 &#123; margin-right : 80px!important&#125;.m-8 &#123; margin : 80px!important&#125;.pt-8 &#123; padding-top : 80px!important&#125;.pb-8 &#123; padding-bottom : 80px!important&#125;.pl-8 &#123; padding-left : 80px!important&#125;.pr-8 &#123; padding-right : 80px!important&#125;.p-8 &#123; padding : 80px!important&#125; 五、常用方法1. 常用颜色方法 更多请看这里详见：https://sass-lang.com/documentation/functions 这些方法都可以直接使用，不需要带前缀 color. 12345lighten (颜色, 百分比) // 调亮darken (颜色, 百分比) // 调暗saturate (颜色, 百分比) // 调高饱和度desaturate (颜色, 百分比) // 降低饱和度transparentize (颜色, 0.0-1.0) // 透明度，注意这里接收的不是百分比，是 0.0-1.0 的小数值 不知道别人，反正我最常用的就是颜色方法了。我自己常常会做一些自己的小工具，一般会定个主题颜色，然后由这个主题颜色生成页面中需要的其它颜色。这个尤其是在定义暗黑模式颜色的时候比较有用，看个我写的例子，我会以 black 为基准，去生成其它颜色： 12345678910111213141516// DARK VALUES$dark-bg : lighten(black, 20%) ;$dark-bg-dark : lighten(black, 15%) ;$dark-bg-selector : lighten(black, 20%) ;$dark-bg-nav : lighten(black, 13%) ;$dark-border : lighten(black, 20%) ;$dark-border-active : lighten(black, 40%) ;$dark-menu-border : #484848 ;$dark-list-header-bg : lighten(black, 12%) ;$dark-list-header-text : lighten(black, 90%) ;$dark-list-bg : lighten(black, 15%) ;$dark-list-bg-active : lighten(black, 20%) ;$dark-text-title : lighten(black, 90%) ;$dark-text : lighten(black, 70%) ;$dark-text-subtitle : lighten(black, 70%) ;$dark-scroll-thumb : lighten(black, 30%) ; 本文在线例子：https://kylebing.cn/test/scss/ SCSS 12345678$green: #4B9E65;.green-original &#123; background-color: $green; &#125;.green-lighten &#123; background-color: lighten($green,20%); &#125;.green-darken &#123; background-color: darken($green,20%); &#125;.green-saturate &#123; background-color: saturate($green,20%); &#125;.green-desaturate &#123; background-color: desaturate($green,20%); &#125;.green-transparent &#123; background-color: transparentize($green, 0.2); &#125; CSS 123456.green-original &#123; background-color: #4B9E65; &#125;.green-lighten &#123; background-color: #88c79c; &#125;.green-darken &#123; background-color: #2a5939; &#125;.green-saturate &#123; background-color: #34b55c; &#125;.green-desaturate &#123; background-color: #62876e; &#125;.green-transparent &#123; background-color: rgba(75, 158, 101, 0.8); &#125; 不过一般工作中不需要这些，因为一般工作中都是有定好的 UI 图为基准的，不需要自己调整颜色，直接取就行，这些颜色方法可能就没太大作用。 2. 高级颜色方法，生成一个渐变的 class 组颜色还可以这么玩，比如你需要展示用户最后登录的时间，这个时间根据距离现在的长短显示不同颜色，比如最近的显示红色，次之的往蓝色方向变化。此时，就需要用到高级一点的颜色方法，我也是今天（2022-08-12）才用到，所以加了上来。 所有高级的颜色处理方法，都在 sass:color 模块里，里面的方法有下面这些，这些方法在使用的时候需要带前缀 color.，比如要使用 adjust 方法，就写为 1color.adjust() 重要！！！在使用颜色模块时，需要在 scss 文件的最上面，添加这段话，不然会出错 1@use &quot;sass:color&quot; 官方说明：https://sass-lang.com/documentation/modules/color 说一下 adjust、change 方法，能看到，这两个方法接收的参数是一样的，其实就是一样的 1234567891011color.change($源颜色, $hue: hue值)// 它其实可以改变 红蓝绿通道的数值、亮度、透明度等，但这里我们只用 $hue，就是改变颜色的色调// 颜色操作@for $item from 0 through 12 &#123; .text-level-#&#123;$item&#125;&#123; margin-right: 15px; font-weight: bold; color: color.change($red, $hue: -30deg * $item) !important; &#125;&#125; 生成 css 例子页面中 我实际的应用页面中是这样的 六、其它1. 方法 @function方法以 @function 开头，以 @return 结尾，也就是说，方法的定义，必须要有返回值 详见：https://sass-lang.com/documentation/at-rules/function 方法的使用跟上面讲到的颜色方法是一样的。方向在定义完成后，可以直接写方法名调用，不需要添加前面的@符号，如： 知道文档的 HTML 根字体大小是 14px，目前需要进行动态尺寸适配，知道其它地方的字体在像素单位上的大小，比如 .font-size-normal 的字体大小是 16px，如何快速方便的计算出 (16&#x2F;14)rem 这样的尺寸呢？对，此时就用到了 Function，非常方便。 rem 单位是以文档根元素(也就是)字体大小为基准的单位，设置成 rem为单位的尺寸后，修改 的字体大小，文档内的以 rem 为单位的尺寸都会跟着变化。这是在适配方面很重要的知识点 SCSS 123456789101112// 比较$root: 14;// 定义一个方法用于换算尺寸的方法// #&#123;&#125; 是输出字符串的，上面有讲@function size($size) &#123; @return #&#123;$size/$root&#125;rem&#125;.font-size-normal &#123; font-size: size(16); &#125; 得出来的CSS是这样的 123.font-size-normal &#123; font-size: 1.1428571429rem;&#125; 2. 除以 ÷ 不使用 &#x2F; 而用 math.div()SCSS 中为了避免跟 css 的一些字体样式混淆（比如 12&#x2F;24px），除法不用 &#x2F; 而是用 math.div() 比如 100 &#x2F; 5 就是。不过你需要在 scss 文件的开头，添加 @use “sass:math”; 12345@use &quot;sass:math&quot;;.gutter&#123; padding: math.div(100px, 5);&#125; 3. 调试方法 @error @warn @debug像 js 的 console.log console.error一样，用于输出提示信息 @debug : 普通输出 @warn : 警告输出 @error : 错误输出 4. 注释1234567/* 多行注释 可以多行 在非压缩模式下，这种注释会被输出到 css 中*/// 单行注释// 这种注释不会输出到 css 中 5. 特殊方法CSS 本身自带一些方法，大多数方法都能与 SCSS 方法和平共存，但有些会产生冲突，如url() 如果 url() 传入的参数是有效的带引号的 url，sass 不会处理它，但还可以往其中插入变量，如果不是有效的带引号的 url，带有方法或变量的，sass 就把它当成正常的方法识别。如： 12345678910$bg-path: &quot;./pics&quot;.card-bg&#123; background: url(&quot;#&#123;$bg-path&#125;/card-bg.png&quot;) center center;&#125;// 或.card-bg&#123; background: url($bg-path+&quot;/card-bg.png&quot;) center center;&#125; 都会输出为 123.card-bg&#123; background: url(&quot;./pics/card-bg.png&quot;) center center;&#125; 6. vue scss 如何加载字体 font以 ~@&#x2F; 开头就可以了 以相对路径 ..&#x2F; 的方式是不可以的 123456789@font-face &#123; font-family: &quot;Impact&quot;; src: url(&quot;~@/assets/font/ImpactPureNumber.ttf&quot;);&#125;@font-face &#123; font-family: &quot;LLPixel&quot;; src: url(&quot;~@/assets/font/LLPixel_only_Letter.ttf&quot;);&#125; 七、写个例子 .btn学会上面的所有内容，我们来写一个例子。比如，你需要写一个按钮库 .btn-success, .btn-danger, .btn-normal, .btn-warning，如果单个定义的话，会很麻烦，现在有了 SCSS，就可以很方便的实现了。 完成后，效果是这样的: 本文在线例子：https://kylebing.cn/test/scss/ 可以 Chrome 打开上面的链接，检查元素，调出调试窗口，点 resources 就可以看到具体的 scss 代码了，还是语法高亮的 SCSS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 定义基础颜色// 一般在项目中会写在 _variables.scss 文件中$green : #4CD964;$syan : #5AC8FA;$blue : #007AFF;$purple : #5856D6;$magenta : #FF2D70;$red : #FF3B30;$orange : #FF9500;$yellow : #FFCC00;$gray : #8E8E93;// 定义需要实现的按钮名和颜色，键值对$btn-types: ( &quot;normal&quot;: white, &quot;primary&quot;: $blue, &quot;success&quot;: $green, &quot;danger&quot;: $red, &quot;warning&quot;: $orange, &quot;second&quot;: $gray,);/****************************把一些常用的需要多平台适配的（-webkit-）做成 mixin 方便调用，写的时候代码也简洁像这种还有 box-shadow transform transition animation 等等一般在项目中都单独定义成一个文件 _utility.scss，直接引用使用，也方便。这里只是提一下，可能会对你有所启发*/@mixin border-radius($value)&#123; -webkit-border-radius: $value; -moz-border-radius: $value; border-radius: $value;&#125;/****************************这里定义最常用的通用方法，比如 .link .btn .block .hidden一般保存为 _normalize.scss 文件*/.unselectable&#123; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125;// .btn 里只放 button 最基础的行为和动作// 下面循环中的 .btn-xxxx 只处理按钮的颜色变化，这样明了.btn &#123; padding: 6px 10px; text-align: center; font-size: 1rem; cursor: pointer; margin-right: 5px; @extend .unselectable; // 引用其它类的内容作为自己的内容，也就是扩展 @include border-radius(5px); // 调用 mixin &amp;:active&#123; transform: translateY(2px); &#125;&#125;@each $name, $color in $btn-types &#123; .btn-#&#123;$name&#125; &#123; @if $name == normal &#123; // 判断 button 名 是否为 &#x27;normal&#x27; color: #333; // 如果是，内部文字颜色为 #333 border: 1px solid darken($color, 20%); &#125; @else &#123; color: white; border: 1px solid darken($color, 5%); &#125; background-color: $color; &amp;:hover&#123; background-color: lighten($color, 5%); &#125; &amp;:active&#123; border-color: transparent; background-color: darken($color, 15%); // 点击的时候按钮背景颜色深 15% &#125; &#125;&#125; 上面的 scss 输出为下面的内容，有没有很强大 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* buttons */.unselectable, .btn &#123; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; &#125;.btn &#123; padding: 6px 10px; text-align: center; font-size: 1rem; cursor: pointer; margin-right: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; &#125; .btn:active &#123; transform: translateY(2px); &#125;.btn-normal &#123; color: #333; border: 1px solid #cccccc; background-color: white; &#125; .btn-normal:hover &#123; background-color: white; &#125; .btn-normal:active &#123; border-color: transparent; background-color: #d9d9d9; &#125;.btn-primary &#123; color: white; border: 1px solid #006ee6; background-color: #007AFF; &#125; .btn-primary:hover &#123; background-color: #1a87ff; &#125; .btn-primary:active &#123; border-color: transparent; background-color: #0055b3; &#125;.btn-success &#123; color: white; border: 1px solid #37d552; background-color: #4CD964; &#125; .btn-success:hover &#123; background-color: #61dd76; &#125; .btn-success:active &#123; border-color: transparent; background-color: #26b33e; &#125;.btn-danger &#123; color: white; border: 1px solid #ff2317; background-color: #FF3B30; &#125; .btn-danger:hover &#123; background-color: #ff534a; &#125; .btn-danger:active &#123; border-color: transparent; background-color: #e30c00; &#125;.btn-warning &#123; color: white; border: 1px solid #e68600; background-color: #FF9500; &#125; .btn-warning:hover &#123; background-color: #ffa01a; &#125; .btn-warning:active &#123; border-color: transparent; background-color: #b36800; &#125;.btn-second &#123; color: white; border: 1px solid #818187; background-color: #8E8E93; &#125; .btn-second:hover &#123; background-color: #9b9b9f; &#125; .btn-second:active &#123; border-color: transparent; background-color: #68686d; &#125; 其实这里可以使用渐变优化按钮颜色的，你可以考虑如何实现哟，加油。给个提示: 基础颜色不需要变，只需要用颜色方法对基础颜色进行微调即可产出渐变需要的颜色 如果你想更深入的了解一些东西，可以看个我一直在完善中的项目《标题日记》： 在线页面https://kylebing.cn/diary/ 源码https://github.com/KyleBing/diary-vue/tree/master/src/assets/scss 八、Vue 中使用 scss在 vue 中使用 scss 需要安装两个组件： sass 和 sass-loader sass 就是用来解析 sass&#x2F;scss 文件内容的，主流的有两个可选项 sass node-sass任选其一即可，但 node-sass 在安装过程中经常出现错误，什么 npm-gpy 错误什么的，我也懒得去看具体是什么原因，烦了就改成 sass 了 vue node-sass 安装失败，如何解决，使用 sass 替换 123456789&quot;devDependencies&quot;: &#123; // 其它组件... &quot;sass&quot;: &quot;^1.26.11&quot;, &quot;sass-loader&quot;: &quot;^10.0.2&quot;&#125;, 然后在 vue 文件中： // scoped 表示在该文件中声明的样式，只在当前文件中有效，不会影响外面样式。 // 具体去查阅 Vue 相关文档 九、学习 scss 最好的例子 Bootstrap v5 - scss 语言: https://github.com/twbs/bootstrap 就是去看 bootstrap v5 的样式源码，bootstrap v4 v5 都是用 scss 写的下载 bootstrap 的 scss 源码，看里面怎么写的，进步很快的。 如果想学 less 可以看这篇 less基础用法（SegmentFault | CSDN）， bootstrap v3 就是用 less 写的。 Bootstrap v3 - less 语言: https://github.com/twbs/bootstrap/tree/v3-dev 十、不太重要的东西语法概览通用 变量声明， $var: value 控制声明，@if @each @error，@warn，@debug CSS 样式，h1 { … } 样式@ @media @font-face @at-root顶级 导入 @import 混合 @mixin 方法定义 @function表达式 数字 12 100px 字符串 Helvetina Neue bold 颜色 #ffffff blue 布尔值 true false null 属性值组 border: 1px solid #ccc Maps (“background”: red, “foreground”: pink)运算符 &#x3D;&#x3D; !&#x3D; &#x2F; % &lt; &lt;&#x3D; &gt;&#x3D; and or not &#x2F; 连接字符 ( ) 其它 变量 $var 方法调用 nth($list,1) var(–main-bg-color) 特殊方法 calc(1px + 100%) url(http://myapp.com/assets/logo.png) 父选择器 &amp; !important","categories":[{"name":"分类","slug":"分类","permalink":"http://example.com/categories/%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"标签","slug":"标签","permalink":"http://example.com/tags/%E6%A0%87%E7%AD%BE/"}],"author":"作者"},{"title":"最全的eslint配置大全","slug":"最全的eslint配置大全","date":"2022-11-01T02:25:08.000Z","updated":"2022-11-01T02:25:08.000Z","comments":true,"path":"2022/11/01/最全的eslint配置大全/","link":"","permalink":"http://example.com/2022/11/01/%E6%9C%80%E5%85%A8%E7%9A%84eslint%E9%85%8D%E7%BD%AE%E5%A4%A7%E5%85%A8/","excerpt":"","text":"最全的eslint配置大全，我已经加了详细中文注释，只需要找到自己想要的配置就可以了，强烈建议收藏！ 用法非常简单，找到 .eslintrc.js下的 rules添加对象即可,比如我要把规则原本 ***单引号***要变为 ***双引号***，那加上”quotes”: [1, “double”] 如果违反了规则情况下，这里的数字：0表示不不处理，1表示警告，2表示错误并退出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238&#123;&quot;rules&quot; : &#123; // 定义对象的set存取器属性时，强制定义get &quot;accessor-pairs&quot;: 2, // 指定数组的元素之间要以空格隔开(,后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;], // 在块级作用域外访问块内定义的变量是否报错提示 &quot;block-scoped-var&quot;: 0, // if while function 后面的&#123;必须与if在同一行，java风格。 &quot;brace-style&quot;: [2, &quot;1tbs&quot;, &#123; &quot;allowSingleLine&quot;: true &#125;], // 双峰驼命名格式 &quot;camelcase&quot;: 2, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， // always-multiline：多行模式必须带逗号，单行模式不能带逗号 &quot;comma-dangle&quot;: [2, &quot;never&quot;], // 控制逗号前后的空格 &quot;comma-spacing&quot;: [2, &#123; &quot;before&quot;: false, &quot;after&quot;: true &#125;], // 控制逗号在行尾出现还是在行首出现 // http://eslint.org/docs/rules/comma-style &quot;comma-style&quot;: [2, &quot;last&quot;], // 圈复杂度 &quot;complexity&quot;: [2,9], // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always &quot;computed-property-spacing&quot;: [2,&quot;never&quot;], // 强制方法必须返回值，TypeScript强类型，不配置 &quot;consistent-return&quot;: 0, // 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了 // e.g [0,&quot;that&quot;] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值 &quot;consistent-this&quot;: 0, // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示 &quot;constructor-super&quot;: 0, // if else while for do后面的代码块是否需要&#123; &#125;包围，参数： // multi 只有块中有多行语句时才需要&#123; &#125;包围 // multi-line 只有块中有多行语句时才需要&#123; &#125;包围, 但是块中的执行语句只有一行时， // 块中的语句只能跟和if语句在同一行。if (foo) foo++; else doSomething(); // multi-or-nest 只有块中有多行语句时才需要&#123; &#125;包围, 如果块中的执行语句只有一行，执行语句可以零另起一行也可以跟在if语句后面 // [2, &quot;multi&quot;, &quot;consistent&quot;] 保持前后语句的&#123; &#125;一致 // default: [2, &quot;all&quot;] 全都需要&#123; &#125;包围 &quot;curly&quot;: [2, &quot;all&quot;], // switch语句强制default分支，也可添加 // no default 注释取消此次警告 &quot;default-case&quot;: 2, // 强制object.key 中 . 的位置，参数: // property，&#x27;.&#x27;号应与属性在同一行 // object, &#x27;.&#x27; 号应与对象名在同一行 &quot;dot-location&quot;: [2, &quot;property&quot;], // 强制使用.号取属性 // 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性 // false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;&quot;allowKeywords&quot;: false&#125;] // allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;&quot;allowPattern&quot;: &quot;^[a-z]+(_[a-z]+)+$&quot;&#125;] &quot;dot-notation&quot;: [2, &#123;&quot;allowKeywords&quot;: true&#125;], // 文件末尾强制换行 &quot;eol-last&quot;: 2, // 使用 === 替代 == &quot;eqeqeq&quot;: [2, &quot;allow-null&quot;], // 方法表达式是否需要命名 &quot;func-names&quot;: 0, // 方法定义风格，参数： // declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, &quot;declaration&quot;] // expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, &quot;expression&quot;] // allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, &quot;declaration&quot;, &#123; &quot;allowArrowFunctions&quot;: true &#125;] &quot;func-style&quot;: 0, &quot;no-alert&quot;: 0,//禁止使用alert confirm prompt &quot;no-array-constructor&quot;: 2,//禁止使用数组构造器 &quot;no-bitwise&quot;: 0,//禁止使用按位运算符 &quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee &quot;no-catch-shadow&quot;: 2,//禁止catch子句参数与外部作用域变量同名 &quot;no-class-assign&quot;: 2,//禁止给类赋值 &quot;no-cond-assign&quot;: 2,//禁止在条件表达式中使用赋值语句 &quot;no-console&quot;: 2,//禁止使用console &quot;no-const-assign&quot;: 2,//禁止修改const声明的变量 &quot;no-constant-condition&quot;: 2,//禁止在条件中使用常量表达式 if(true) if(1) &quot;no-continue&quot;: 0,//禁止使用continue &quot;no-control-regex&quot;: 2,//禁止在正则表达式中使用控制字符 &quot;no-debugger&quot;: 2,//禁止使用debugger &quot;no-delete-var&quot;: 2,//不能对var声明的变量使用delete操作符 &quot;no-div-regex&quot;: 1,//不能使用看起来像除法的正则表达式/=foo/ &quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125; &quot;no-dupe-args&quot;: 2,//函数参数不能重复 &quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复 &quot;no-else-return&quot;: 2,//如果if语句里面有return,后面不能跟else语句 &quot;no-empty&quot;: 2,//块语句中的内容不能为空 &quot;no-empty-character-class&quot;: 2,//正则表达式中的[]内容不能为空 &quot;no-empty-label&quot;: 2,//禁止使用空label &quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符 &quot;no-eval&quot;: 1,//禁止使用eval &quot;no-ex-assign&quot;: 2,//禁止给catch语句中的异常参数赋值 &quot;no-extend-native&quot;: 2,//禁止扩展native对象 &quot;no-extra-bind&quot;: 2,//禁止不必要的函数绑定 &quot;no-extra-boolean-cast&quot;: 2,//禁止不必要的bool转换 &quot;no-extra-parens&quot;: 2,//禁止非必要的括号 &quot;no-extra-semi&quot;: 2,//禁止多余的冒号 &quot;no-fallthrough&quot;: 1,//禁止switch穿透 &quot;no-floating-decimal&quot;: 2,//禁止省略浮点数中的0 .5 3. &quot;no-func-assign&quot;: 2,//禁止重复的函数声明 &quot;no-implicit-coercion&quot;: 1,//禁止隐式转换 &quot;no-implied-eval&quot;: 2,//禁止使用隐式eval &quot;no-inline-comments&quot;: 0,//禁止行内备注 &quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],//禁止在块语句中使用声明（变量或函数） &quot;no-invalid-regexp&quot;: 2,//禁止无效的正则表达式 &quot;no-invalid-this&quot;: 2,//禁止无效的this，只能用在构造器，类，对象字面量 &quot;no-irregular-whitespace&quot;: 2,//不能有不规则的空格 &quot;no-iterator&quot;: 2,//禁止使用__iterator__ 属性 &quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同 &quot;no-labels&quot;: 2,//禁止标签声明 &quot;no-lone-blocks&quot;: 2,//禁止不必要的嵌套块 &quot;no-lonely-if&quot;: 2,//禁止else语句内只有if语句 &quot;no-loop-func&quot;: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以） &quot;no-mixed-requires&quot;: [0, false],//声明时不能混用声明类型 &quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格 &quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格 &quot;no-multi-spaces&quot;: 1,//不能用多余的空格 &quot;no-multi-str&quot;: 2,//字符串不能用\\换行 &quot;no-multiple-empty-lines&quot;: [1, &#123;&quot;max&quot;: 2&#125;],//空行最多不能超过2行 &quot;no-native-reassign&quot;: 2,//不能重写native对象 &quot;no-negated-in-lhs&quot;: 2,//in 操作符的左边不能有! &quot;no-nested-ternary&quot;: 0,//禁止使用嵌套的三目运算 &quot;no-new&quot;: 1,//禁止在使用new构造一个实例后不赋值 &quot;no-new-func&quot;: 1,//禁止使用new Function &quot;no-new-object&quot;: 2,//禁止使用new Object() &quot;no-new-require&quot;: 2,//禁止使用new require &quot;no-new-wrappers&quot;: 2,//禁止使用new创建包装实例，new String new Boolean new Number &quot;no-obj-calls&quot;: 2,//不能调用内置的全局对象，比如Math() JSON() &quot;no-octal&quot;: 2,//禁止使用八进制数字 &quot;no-octal-escape&quot;: 2,//禁止使用八进制转义序列 &quot;no-param-reassign&quot;: 2,//禁止给参数重新赋值 &quot;no-path-concat&quot;: 0,//node中不能使用__dirname或__filename做路径拼接 &quot;no-plusplus&quot;: 0,//禁止使用++，-- &quot;no-process-env&quot;: 0,//禁止使用process.env &quot;no-process-exit&quot;: 0,//禁止使用process.exit() &quot;no-proto&quot;: 2,//禁止使用__proto__属性 &quot;no-redeclare&quot;: 2,//禁止重复声明变量 &quot;no-regex-spaces&quot;: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/ &quot;no-restricted-modules&quot;: 0,//如果禁用了指定模块，使用就会报错 &quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式 &quot;no-script-url&quot;: 0,//禁止使用javascript:void(0) &quot;no-self-compare&quot;: 2,//不能比较自身 &quot;no-sequences&quot;: 0,//禁止使用逗号运算符 &quot;no-shadow&quot;: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名 &quot;no-shadow-restricted-names&quot;: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用 &quot;no-spaced-func&quot;: 2,//函数调用时 函数名与()之间不能有空格 &quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2] &quot;no-sync&quot;: 0,//nodejs 禁止同步方法 &quot;no-ternary&quot;: 0,//禁止使用三目运算符 &quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格 &quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super &quot;no-throw-literal&quot;: 2,//禁止抛出字面量错误 throw &quot;error&quot;; &quot;no-undef&quot;: 1,//不能有未定义的变量 &quot;no-undef-init&quot;: 2,//变量初始化时不能直接给它赋值为undefined &quot;no-undefined&quot;: 2,//不能使用undefined &quot;no-unexpected-multiline&quot;: 2,//避免多行表达式 &quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾 &quot;no-unneeded-ternary&quot;: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false; &quot;no-unreachable&quot;: 2,//不能有无法执行的代码 &quot;no-unused-expressions&quot;: 2,//禁止无用的表达式 &quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;],//不能有声明后未被使用的变量或参数 &quot;no-use-before-define&quot;: 2,//未定义前不能使用 &quot;no-useless-call&quot;: 2,//禁止不必要的call和apply &quot;no-void&quot;: 2,//禁用void操作符 &quot;no-var&quot;: 0,//禁用var，用let和const代替 &quot;no-warning-comments&quot;: [1, &#123; &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; &#125;],//不能有警告备注 &quot;no-with&quot;: 2,//禁用with &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格 &quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来 &quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号 &quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter &quot;block-scoped-var&quot;: 0,//块语句中使用var &quot;brace-style&quot;: [1, &quot;1tbs&quot;],//大括号风格 &quot;callback-return&quot;: 1,//避免多次调用回调什么的 &quot;camelcase&quot;: 2,//强制驼峰法命名 &quot;comma-dangle&quot;: [2, &quot;never&quot;],//对象字面量项尾不能有逗号 &quot;comma-spacing&quot;: 0,//逗号前后的空格 &quot;comma-style&quot;: [2, &quot;last&quot;],//逗号风格，换行时在行首还是行尾 &quot;complexity&quot;: [0, 11],//循环复杂度 &quot;computed-property-spacing&quot;: [0, &quot;never&quot;],//是否允许计算后的键名什么的 &quot;consistent-return&quot;: 0,//return 后面是否允许省略 &quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名 &quot;constructor-super&quot;: 0,//非派生类不能调用super，派生类必须调用super &quot;curly&quot;: [2, &quot;all&quot;],//必须使用 if()&#123;&#125; 中的&#123;&#125; &quot;default-case&quot;: 2,//switch语句最后必须有default &quot;dot-location&quot;: 0,//对象访问符的位置，换行的时候在行首还是行尾 &quot;dot-notation&quot;: [0, &#123; &quot;allowKeywords&quot;: true &#125;],//避免不必要的方括号 &quot;eol-last&quot;: 0,//文件以单一的换行符结束 &quot;eqeqeq&quot;: 2,//必须使用全等 &quot;func-names&quot;: 0,//函数表达式必须有名字 &quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式 &quot;generator-star-spacing&quot;: 0,//生成器函数*的前后空格 &quot;guard-for-in&quot;: 0,//for in循环要用if语句过滤 &quot;handle-callback-err&quot;: 0,//nodejs 处理错误 &quot;id-length&quot;: 0,//变量名长度 &quot;indent&quot;: [2, 4],//缩进风格 &quot;init-declarations&quot;: 0,//声明时必须赋初值 &quot;key-spacing&quot;: [0, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;],//对象字面量中冒号的前后空格 &quot;lines-around-comment&quot;: 0,//行前/行后备注 &quot;max-depth&quot;: [0, 4],//嵌套块深度 &quot;max-len&quot;: [0, 80, 4],//字符串最大长度 &quot;max-nested-callbacks&quot;: [0, 2],//回调嵌套深度 &quot;max-params&quot;: [0, 3],//函数最多只能有3个参数 &quot;max-statements&quot;: [0, 10],//函数内最多有几个声明 &quot;new-cap&quot;: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用 &quot;new-parens&quot;: 2,//new时必须加小括号 &quot;newline-after-var&quot;: 2,//变量声明后是否需要空一行 &quot;object-curly-spacing&quot;: [0, &quot;never&quot;],//大括号内是否允许不必要的空格 &quot;object-shorthand&quot;: 0,//强制对象字面量缩写语法 &quot;one-var&quot;: 1,//连续声明 &quot;operator-assignment&quot;: [0, &quot;always&quot;],//赋值运算符 += -=什么的 &quot;operator-linebreak&quot;: [2, &quot;after&quot;],//换行时运算符在行尾还是行首 &quot;padded-blocks&quot;: 0,//块语句内行首行尾是否要空行 &quot;prefer-const&quot;: 0,//首选const &quot;prefer-spread&quot;: 0,//首选展开运算 &quot;prefer-reflect&quot;: 0,//首选Reflect的方法 &quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 `` &quot;&quot; &#x27;&#x27; &quot;quote-props&quot;:[2, &quot;always&quot;],//对象字面量中的属性名是否强制双引号 &quot;radix&quot;: 2,//parseInt必须指定第二个参数 &quot;id-match&quot;: 0,//命名检测 &quot;require-yield&quot;: 0,//生成器函数必须有yield &quot;semi&quot;: [2, &quot;always&quot;],//语句强制分号结尾 &quot;semi-spacing&quot;: [0, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;],//分号前后空格 &quot;sort-vars&quot;: 0,//变量声明时排序 &quot;space-after-keywords&quot;: [0, &quot;always&quot;],//关键字后面是否要空一格 &quot;space-before-blocks&quot;: [0, &quot;always&quot;],//不以新行开始的块&#123;前面要不要有空格 &quot;space-before-function-paren&quot;: [0, &quot;always&quot;],//函数定义时括号前面要不要有空格 &quot;space-in-parens&quot;: [0, &quot;never&quot;],//小括号里面要不要有空格 &quot;space-infix-ops&quot;: 0,//中缀操作符周围要不要有空格 &quot;space-return-throw-case&quot;: 2,//return throw case后面要不要加空格 &quot;space-unary-ops&quot;: [0, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;],//一元运算符的前/后要不要加空格 &quot;spaced-comment&quot;: 0,//注释风格不要有空格什么的 &quot;strict&quot;: 2,//使用严格模式 &quot;use-isnan&quot;: 2,//禁止比较时使用NaN，只能用isNaN() &quot;valid-jsdoc&quot;: 0,//jsdoc规则 &quot;valid-typeof&quot;: 2,//必须使用合法的typeof的值 &quot;vars-on-top&quot;: 2,//var必须放在作用域顶部 &quot;wrap-iife&quot;: [2, &quot;inside&quot;],//立即执行函数表达式的小括号风格 &quot;wrap-regex&quot;: 0,//正则表达式字面量用小括号包起来 &quot;yoda&quot;: [2, &quot;never&quot;]//禁止尤达条件 &#125;&#125;","categories":[{"name":"分类","slug":"分类","permalink":"http://example.com/categories/%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"标签","slug":"标签","permalink":"http://example.com/tags/%E6%A0%87%E7%AD%BE/"}],"author":"作者"},{"title":"前端核心工具：yarn、npm、cnpm三者如何优雅的在一起使用","slug":"前端核心工具：yarn、npm、cnpm三者如何优雅的在一起使用","date":"2022-11-01T02:17:36.000Z","updated":"2022-11-01T02:17:36.000Z","comments":true,"path":"2022/11/01/前端核心工具：yarn、npm、cnpm三者如何优雅的在一起使用/","link":"","permalink":"http://example.com/2022/11/01/%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%EF%BC%9Ayarn%E3%80%81npm%E3%80%81cnpm%E4%B8%89%E8%80%85%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/","excerpt":"","text":"一位用不好包管理器的前端，是一个入门级前端，一个用不好webpack的前端，是一个初级前端三个包管理器是可以一起用的，只要你够胆大心细，就没任何问题！ 推荐两篇文章 手写优化版React脚手架 手写Vue的脚手架 前端性能优化不完全手册 在javeScript编写中,我们尽量不要定义全局变量，封装函数尽量不要有副作用,因为全部变量的查询时间会比局部变量的查询慢,更是考虑在Node的环境中无法被垃圾回收的问题老规矩 先看原理npm npm 是 Node.js 能够如此成功的主要原因之一。npm 团队做了很多的工作，以确保 npm 保持向后兼容，并在不同的环境中保持一致。 npm是围绕着 语义版本控制（semver）的思想而设计。 给定一个版本号：主版本号.次版本号.补丁版本号， 以下这三种情况需要增加相应的版本号： 主版本号： 当API发生改变，并与之前的版本不兼容的时候 次版本号： 当增加了功能，但是向后兼容的时候 补丁版本号：当做了向后兼容的缺陷修复的时候 npm 2 会安装每一个包所依赖的所有依赖项。如果我们有这么一个项目，它依赖项目A，项目A依赖项目B，项目B依赖项目C，那么依赖树将如下所示： 这个结构可能会很长。这对于基于Unix的操作系统来说只不过是一个小烦恼，但对于Windows来说却是个破坏性的东西，因为有很多程序无法处理超过260个字符的文件路径名。 npm 3采用了扁平依赖关系树来解决这个问题，所以我们的3个项目结构现在看起来如下所示： 存了已经下载的每个版本的压缩包。本地缓存的内容可以通过npm cache ls命令进行查看。本地缓存的设计有助于减少安装时间。 这样，一个原来很长的文件路径名就从./node_modules/package-A/node_modules/package-B/node-modules/some-file-name-in-package-c.js变成了/node_modules/some-file-name-in-package-c.js。 这种方法的缺点是，npm必须首先遍历所有的项目依赖关系，然后再决定如何生成扁平的node_modules目录结构。npm必须为所有使用到的模块构建一个完整的依赖关系树，这是一个耗时的操作，是npm安装速度慢的一个很重要的原因。 想当然的以为每次运行npm install命令时，NPM都得从互联网上下载所有内容。 但是，npm是有本地缓存的，它保存了已经下载的每个版本的压缩包。本地缓存的内容可以通过npm cache ls命令进行查看。本地缓存的设计有助于减少安装时间。 cnpm cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm。 npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，于是淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。” 官方地址：http://npm.taobao.org 安装： npm install -g cnpm --registry=https://registry.npm.taobao.org Yarn Yarn一开始的主要目标是解决上一节中描述的由于语义版本控制而导致的npm安装的不确定性问题。虽然可以使用npm shrinkwrap来实现可预测的依赖关系树，但它并不是默认选项，而是取决于所有的开发人员知道并且启用这个选项。 Yarn采取了不同的做法。每个yarn安装都会生成一个类似于npm-shrinkwrap.json的yarn.lock文件，而且它是默认创建的。除了常规信息之外，yarn.lock文件还包含要安装的内容的校验和，以确保使用的库的版本相同。 yarn是经过重新设计的崭新的npm客户端，它能让开发人员并行处理所有必须的操作，并添加了一些其他改进。 运行速度得到了显著的提升，整个安装时间也变得更少 像npm一样，yarn使用本地缓存。**与npm不同的是，yarn无需互联网连接就能安装本地缓存的依赖项，它提供了离线模式**。 允许合并项目中使用到的所有的包的许可证 通常情况下不建议通过npm进行安装。npm安装是非确定性的，程序包没有签名，并且npm除了做了基本的SHA1哈希之外不执行任何完整性检查，这给安装系统程序带来了安全风险。(作者曾经在一个上百个依赖包的项目中使用npm丢包过，代价非常大，泪水不自觉掉下来) 首先看一次非常失败的包下载 竟然是从全局读取的资源(不配置webpack别名是因为就这一个路径这么长) 首先我们从原理入手 ，我们使用 npm init,yarn init,cnpm init 的时候 发生了什么 ？ 生成package.json文件 json文件内部声明初始的版本信息、作者信息等，如果你是需要上传到npm上作为命令行工具，应该配置bin等声明入口字段 那么当我们使用npm i , yarn add ,cnpm i 操作时候会发生什么 ？ 首先会根据你的命令行后缀是否加了 -g 或者global判断，下载的包是放在全局的环境，还是当前package.json文件对应的node_module文件夹目录下(这点尤其重要，有人出BUG，就是因为在用npm , cnpm时候没有注明添加的是全局依赖还是本地依赖，导致json文件上没有对应的包名，项目永远起不来) 然后根据你的指令--save 或者-D、--save -dev判断是开发依赖还是线上依赖，其实这点在yarn上没有问题，因为yarn有自己的一套检查包完整性的机制，不会丢包，还会自动判断添加依赖，出bug一般是cnpm和npm，没有明确-g或者--save，npm只有检查程序员签名的机制，没有检查包完整性的机制，也不会自动添加依赖到json文件，那么就会出现丢包的假象，所以建议主要使用yarn yarn和npm对比 npm的缺点汇总： 同一个项目，安装的时候无法保持一致性。由于package.json文件中版本号的特点，下面三个版本号在安装的时候代表不同的含义。 123&quot;5.0.3&quot;,&quot;~5.0.3&quot;,&quot;^5.0.3&quot; “5.0.3”表示安装指定的5.0.3版本，“～5.0.3”表示安装5.0.X中最新的版本，“^5.0.3”表示安装5.X.X中最新的版本。这就麻烦了，常常会出现同一个项目，有的同事是OK的，有的同事会由于安装的版本不一致出现bug。 安装的时候，包会在同一时间下载和安装，中途某个时候，一个包抛出了一个错误，但是npm会继续下载和安装包。因为npm会把所有的日志输出到终端，有关错误包的错误信息就会在一大堆npm打印的警告中丢失掉，并且你甚至永远不会注意到实际发生的错误。 yarn的优点 速度快 。速度快主要来自以下两个方面： 并行安装：无论 npm 还是Yarn在执行包的安装时，都会执行一系列任务。npm 是按照队列执行每个 package，也就是说必须要等到当前package安装完成之后，才能继续后面的安装。而 Yarn 是并行执行所有任务，提高了性能。 离线模式：**如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。** 安装版本统一：为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。npm 其实也有办法实现处处使用相同版本的 packages，但需要开发者执行 npm shrinkwrap 命令。这个命令将会生成一个锁定文件，在执行 npm install 的时候，该锁定文件会先被读取，和 Yarn 读取 yarn.lock 文件一个道理。npm 和 Yarn 两者的不同之处在于，Yarn 默认会生成这样的锁定文件，而 npm 要通过 shrinkwrap 命令生成 npm-shrinkwrap.json 文件，只有当这个文件存在的时候，packages 版本信息才会被记录和更新。 更简洁的输出：npm 的输出信息比较冗长。在执行 npm install &lt;package&gt; 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn 简洁太多：默认情况下，结合了 emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。 多注册来源处理：所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。 更好的语义化： yarn改变了一些npm命令的名称，比如 yarn add/remove，感觉上比npm原本的 install/uninstall 要更清晰。 那不是标题党？ 说了yarn这么多优点，我们为什么还要npm呢？ 你不用npm publish ，你怎么上传包到npm? 你不用cnpm，是下载不了一些包的 搞清楚三者下载包（依赖）的本质结果： 首先向对应的node_module文件夹下面下载包（如果你非要下到全局，那么再见） 再然后是json文件中添加对应的依赖字段,确定是线上依赖还是开发依赖 只要做到这两者 你就下包成功 总结就是 只要结果 过程管你是啥 使用yarn下载过的包，再使用npm cnpm下载 会重复下载，删除之前的包 puppeteer这个包所依赖的mini版谷歌浏览器使用cnpm下载就可以完美解决 prerender-spa-plugin这个包依赖上面的木偶戏 puppeteer这个包，也可以用cnpm下载 混合使用包管理器切记，不要重复下载依赖，npm cnpm下载依赖，一定要添加注明是什么依赖，是否全局安装 yarn和npm i两者，选择前者，原因在上面有提到，总体来说，yarn是不二选择，但是其他两者也不可缺少，比如electron这个依赖，使用cnpm就可以完美一键安装","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"作者"},{"title":"git删除远程分支后，本地同步问题","slug":"git删除远程分支后，本地同步问题","date":"2022-11-01T02:00:18.000Z","updated":"2022-11-01T02:00:18.000Z","comments":true,"path":"2022/11/01/git删除远程分支后，本地同步问题/","link":"","permalink":"http://example.com/2022/11/01/git%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%90%8E%EF%BC%8C%E6%9C%AC%E5%9C%B0%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/","excerpt":"","text":"项目里不小心把本地分支给提交到了远程，而且名字还起错了，在删除远程分支后，发现 1git branch 时，那个被删除的分支已经看不到，应该是被删除，然而在 1git branch -a 后，居然还能看到那个被删除的远程分支，求过某娘后，发现应该是本地未能同步的原因。解决方法只有一行命令 1git fetch -p 然后再看，果然没了。。。","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}],"author":"作者"},{"title":"前端跨域问题如何解决","slug":"前端跨域问题如何解决","date":"2022-11-01T01:45:58.000Z","updated":"2022-11-01T01:45:58.000Z","comments":true,"path":"2022/11/01/前端跨域问题如何解决/","link":"","permalink":"http://example.com/2022/11/01/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/","excerpt":"","text":"前端跨域问题如何解决咱们做前端的，平时跟后端对接接口那是必须的事情，但是可能很多同学忽略了一个对接过程中可能会发生的问题——跨域，那跨域到底是啥呢？为什么会跨域呢？又怎么才能解决呢？ 为什么跨域？为什么会出现跨域问题呢？那就不得不讲浏览器的同源策略了，它规定了协议号-域名-端口号这三者必须都相同才符合同源策略 如有有一个不相同，就会出现跨域问题，不符合同源策略导致的后果有 1、LocalStorge、SessionStorge、Cookie等浏览器内存无法跨域访问 2、DOM节点无法跨域操作 3、Ajax请求无法跨域请求 注意点：一个IP是可以注册多个不同域名的，也就是多个域名可能指向同一个IP，即使是这样，他们也不符合同源策略 跨域的时机？跨域发生在什么时候呢？我考过很多位同学，得到了两种答案 1、请求一发出就被浏览器的跨域报错拦下来了(大多数人回答) 2、请求发出去到后端，后端返回数据，在浏览器接收后端数据时被浏览器的跨域报错拦下来那到底是哪种呢？我们可以验证下，咱们先npm i nodemon -g，然后创建一个index.js，然后nodemon index起一个node服务 1234567891011121314// index.js http://127.0.0.1:8000const http = require(&#x27;http&#x27;);const port = 8000;http.createServer(function (req, res) &#123; const &#123; query &#125; = urllib.parse(req.url, true); console.log(query.name) console.log(&#x27;到后端喽&#x27;) res.end(JSON.stringify(&#x27;林三心&#x27;));&#125;).listen(port, function () &#123; console.log(&#x27;server is listening on port &#x27; + port);&#125;) 再创建一个index.html，用来写前端的请求代码，咱们就写一个简单的AJAX请求吧 &#x2F;&#x2F; index.html http://127.0.0.1:5500/index.html //步骤一:创建异步对象 var ajax = new XMLHttpRequest(); //步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数 ajax.open('get', 'http://127.0.0.1:8000?name=前端过来的林三心'); //步骤三:发送请求 ajax.send(); //步骤四:注册事件 onreadystatechange 状态改变就会调用 ajax.onreadystatechange = function () { if (ajax.readyState == 4 && ajax.status == 200) { //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的 console.log(ajax.responseText);//输入相应的内容 } } 最终，前端确实是跨域报错了。但这不是结果，我们要想知道是哪一个答案，关键在于看后端的node服务那里有没有输出，就一目了然了。所以，答案2才是对的。 同域情况 &amp;&amp; 跨域情况？前面提到了同源策略，满足协议号-域名-端口号这三者都相同就是同域，反之就是跨域，会导致跨域报错，下面通过几个例子让大家巩固一下对同域和跨域的认识把！ 解决跨域的方案跨域其实是一个很久的问题了，对应的解决方案也有很多，一起接着往下读吧！！！ JSONP前面咱们说了，因为浏览器同源策略的存在，导致存在跨域问题，那有没有不受跨域问题所束缚的东西呢？其实是有的，以下这三个标签加载资源路径是不受束缚的 1、script标签： 2、link标签： 3、img标签：而JSONP就是利用了script的src加载不受束缚，从而可以拥有从不同的域拿到数据的能力。但是JSONP需要前端后端配合，才能实现最终的跨域获取数据。 JSONP通俗点说就是：利用script的src去发送请求，将一个方法名callback传给后端，后端拿到这个方法名，将所需数据，通过字符串拼接成新的字符串callback(所需数据)，并发送到前端，前端接收到这个字符串之后，就会自动执行方法callback(所需数据)。 后端代码 1234567891011121314151617181920// index.js http://127.0.0.1:8000const http = require(&#x27;http&#x27;);const urllib = require(&#x27;url&#x27;);const port = 8000;http.createServer(function (req, res) &#123; const &#123; query &#125; = urllib.parse(req.url, true); if (query &amp;&amp; query.callback) &#123; const &#123; name, age, callback &#125; = query const person = `$&#123;name&#125;今年$&#123;age&#125;岁啦！！！` const str = `$&#123;callback&#125;($&#123;JSON.stringify(person)&#125;)` // 拼成callback(data) res.end(str); &#125; else &#123; res.end(JSON.stringify(&#x27;没东西啊你&#x27;)); &#125;&#125;).listen(port, function () &#123; console.log(&#x27;server is listening on port &#x27; + port);&#125;) 前端代码// index.html http://127.0.0.1:5500/index.html const jsonp = (url, params, cbName) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const script = document.createElement(&#39;script&#39;) window[cbName] = (data) =&gt; &#123; resolve(data) document.body.removeChild(script) &#125; params = &#123; ...params, callback: cbName &#125; const arr = Object.keys(params).map(key =&gt; `$&#123;key&#125;=$&#123;params[key]&#125;`) script.src = `$&#123;url&#125;?$&#123;arr.join(&#39;&amp;&#39;)&#125;` document.body.appendChild(script) &#125;) &#125; jsonp(&#39;http://127.0.0.1:8000&#39;, &#123; name: &#39;林三心&#39;, age: 23 &#125;, &#39;callback&#39;).then(data =&gt; &#123; console.log(data) // 林三心今年23岁啦！！！ &#125;) JSONP的缺点就是，需要前后端配合，并且只支持get请求方法 WebSocket我理解的WebSocket是一种协议(跟http同级，都是协议)，并且他可以进行跨域通信。 后端代码先安装npm i ws 123456789101112// index.js http://127.0.0.1:8000const Websocket = require(&#x27;ws&#x27;);const port = 8000;const ws = new Websocket.Server(&#123; port &#125;)ws.on(&#x27;connection&#x27;, (obj) =&gt; &#123; obj.on(&#x27;message&#x27;, (data) =&gt; &#123; data = JSON.parse(data.toString()) const &#123; name, age &#125; = data obj.send(`$&#123;name&#125;今年$&#123;age&#125;岁啦！！！`) &#125;)&#125;) 前端代码// index.html http://127.0.0.1:5500/index.html function myWebsocket(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; const socket = new WebSocket(url) socket.onopen = () =&gt; &#123; socket.send(JSON.stringify(params)) &#125; socket.onmessage = (e) =&gt; &#123; resolve(e.data) &#125; &#125;) &#125; myWebsocket(&#39;ws://127.0.0.1:8000&#39;, &#123; name: &#39;林三心&#39;, age: 23 &#125;).then(data =&gt; &#123; console.log(data) // 林三心今年23岁啦！！！ &#125;) CorsCors，全称是Cross-Origin Resource Sharing，意思是跨域资源共享，Cors一般是由后端来开启的，一旦开启，前端就可以跨域访问后端。 为什么后端开启Cors，前端就能跨域请求后端呢？我的理解是：前端跨域访问到后端，后端开启Cors，发送Access-Control-Allow-Origin: 域名 字段到前端（其实不止一个），前端浏览器判断Access-Control-Allow-Origin的域名如果跟前端域名一样，浏览器就不会实行跨域拦截，从而解决跨域问题。 后端代码12345678910111213141516171819202122// index.js http://127.0.0.1:8000const http = require(&#x27;http&#x27;);const urllib = require(&#x27;url&#x27;);const port = 8000;http.createServer(function (req, res) &#123; // 开启Cors res.writeHead(200, &#123; //设置允许跨域的域名，也可设置*允许所有域名 &#x27;Access-Control-Allow-Origin&#x27;: &#x27;http://127.0.0.1:5500&#x27;, //跨域允许的请求方法，也可设置*允许所有方法 &quot;Access-Control-Allow-Methods&quot;: &quot;DELETE,PUT,POST,GET,OPTIONS&quot;, //允许的header类型 &#x27;Access-Control-Allow-Headers&#x27;: &#x27;Content-Type&#x27; &#125;) const &#123; query: &#123; name, age &#125; &#125; = urllib.parse(req.url, true); res.end(`$&#123;name&#125;今年$&#123;age&#125;岁啦！！！`);&#125;).listen(port, function () &#123; console.log(&#x27;server is listening on port &#x27; + port);&#125;) 前端代码1234567891011121314// index.html http://127.0.0.1:5500/index.html //步骤一:创建异步对象 var ajax = new XMLHttpRequest(); //步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数 ajax.open(&#x27;get&#x27;, &#x27;http://127.0.0.1:8000?name=林三心&amp;age=23&#x27;); //步骤三:发送请求 ajax.send(); //步骤四:注册事件 onreadystatechange 状态改变就会调用 ajax.onreadystatechange = function () &#123; if (ajax.readyState == 4 &amp;&amp; ajax.status == 200) &#123; //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的 console.log(ajax.responseText);//输入相应的内容 &#125; &#125; Node接口代理还是回到同源策略，同源策略它只是浏览器的一个策略而已，它是限制不到后端的，也就是前端-后端会被同源策略限制，但是后端-后端则不会被限制，所以可以通过Node接口代理，先访问已设置Cors的后端1，再让后端1去访问后端2获取数据到后端1，后端1再把数据传到前端 后端2代码1234567891011121314// index.js http://127.0.0.1:8000const http = require(&#x27;http&#x27;);const urllib = require(&#x27;url&#x27;);const port = 8000;http.createServer(function (req, res) &#123; console.log(888) const &#123; query: &#123; name, age &#125; &#125; = urllib.parse(req.url, true); res.end(`$&#123;name&#125;今年$&#123;age&#125;岁啦！！！`)&#125;).listen(port, function () &#123; console.log(&#x27;server is listening on port &#x27; + port);&#125;) 创建一个index2.js，并nodmeon index2.js 后端1代码12345678910111213141516171819202122232425262728293031323334// index2.js http://127.0.0.1:8888const http = require(&#x27;http&#x27;);const urllib = require(&#x27;url&#x27;);const querystring = require(&#x27;querystring&#x27;);const port = 8888;http.createServer(function (req, res) &#123; // 开启Cors res.writeHead(200, &#123; //设置允许跨域的域名，也可设置*允许所有域名 &#x27;Access-Control-Allow-Origin&#x27;: &#x27;http://127.0.0.1:5500&#x27;, //跨域允许的请求方法，也可设置*允许所有方法 &quot;Access-Control-Allow-Methods&quot;: &quot;DELETE,PUT,POST,GET,OPTIONS&quot;, //允许的header类型 &#x27;Access-Control-Allow-Headers&#x27;: &#x27;Content-Type&#x27; &#125;) const &#123; query &#125; = urllib.parse(req.url, true); const &#123; methods = &#x27;GET&#x27;, headers &#125; = req const proxyReq = http.request(&#123; host: &#x27;127.0.0.1&#x27;, port: &#x27;8000&#x27;, path: `/?$&#123;querystring.stringify(query)&#125;`, methods, headers &#125;, proxyRes =&gt; &#123; proxyRes.on(&#x27;data&#x27;, chunk =&gt; &#123; console.log(chunk.toString()) res.end(chunk.toString()) &#125;) &#125;).end()&#125;).listen(port, function () &#123; console.log(&#x27;server is listening on port &#x27; + port);&#125;) 前端代码123456789101112131415// index.html http://127.0.0.1:5500//步骤一:创建异步对象 var ajax = new XMLHttpRequest(); //步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端 ajax.open(&#x27;get&#x27;, &#x27;http://127.0.0.1:8888?name=林三心&amp;age=23&#x27;); //步骤三:发送请求 ajax.send(); //步骤四:注册事件 onreadystatechange 状态改变就会调用 ajax.onreadystatechange = function () &#123; if (ajax.readyState == 4 &amp;&amp; ajax.status == 200) &#123; //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的 console.log(ajax.responseText);//输入相应的内容 &#125; &#125; Nginx其实Nginx跟Node接口代理是一个道理，只不过Nginx就不需要我们自己去搭建一个中间服务 先下载nginx，然后将nginx目录下的nginx.conf修改如下: 12345678server&#123; listen 8888; server_name 127.0.0.1; location /&#123; proxy_pass 127.0.0.1:8000; &#125;&#125; 最后通过命令行nginx -s reload启动nginx 后端代码1234567891011121314// index.js http://127.0.0.1:8000const http = require(&#x27;http&#x27;);const urllib = require(&#x27;url&#x27;);const port = 8000;http.createServer(function (req, res) &#123; const &#123; query: &#123; name, age &#125; &#125; = urllib.parse(req.url, true); res.end(`$&#123;name&#125;今年$&#123;age&#125;岁啦！！！`);&#125;).listen(port, function () &#123; console.log(&#x27;server is listening on port &#x27; + port);&#125;) 前端代码123456789101112131415// index.html http://127.0.0.1:5500//步骤一:创建异步对象 var ajax = new XMLHttpRequest(); //步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端 ajax.open(&#x27;get&#x27;, &#x27;http://127.0.0.1:8888?name=林三心&amp;age=23&#x27;); //步骤三:发送请求 ajax.send(); //步骤四:注册事件 onreadystatechange 状态改变就会调用 ajax.onreadystatechange = function () &#123; if (ajax.readyState == 4 &amp;&amp; ajax.status == 200) &#123; //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的 console.log(ajax.responseText);//输入相应的内容 &#125; &#125; postMessage场景：http://127.0.0.1:5500/index.html页面中使用了iframe标签内嵌了一个http://127.0.0.1:5555/index.html的页面 虽然这两个页面存在于一个页面中，但是需要iframe标签来嵌套才行，这两个页面之间是无法进行通信的，因为他们端口号不同，根据同源策略，他们之间存在跨域问题 那应该怎么办呢？使用postMessage可以使这两个页面进行通信 1234567891011121314// http:127.0.0.1:5500/index.html&lt;body&gt; &lt;iframe src=&quot;http://127.0.0.1:5555/index.html&quot; id=&quot;frame&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;script&gt; document.getElementById(&#x27;frame&#x27;).onload = function () &#123; this.contentWindow.postMessage(&#123; name: &#x27;林三心&#x27;, age: 23 &#125;, &#x27;http://127.0.0.1:5555&#x27;) window.onmessage = function (e) &#123; console.log(e.data) // 林三心今年23岁啦！！！ &#125; &#125;&lt;/script&gt; 12345678// http://127.0.0.1:5555/index.html&lt;script&gt; window.onmessage = function (e) &#123; const &#123; data: &#123; name, age &#125;, origin &#125; = e e.source.postMessage(`$&#123;name&#125;今年$&#123;age&#125;岁啦！！！`, origin) &#125;&lt;/script&gt; document.domain &amp;&amp; iframe场景：a.sanxin.com&#x2F;index.html 与 b.sanxin.com&#x2F;index.html之间的通信 其实上面这两个正常情况下是无法通信的，因为他们的域名不相同，属于跨域通信 那怎么办呢？其实他们有一个共同点，那就是他们的二级域名都是sanxin.com，这使得他们可以通过document.domain &amp;&amp; iframe的方式来通信","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"作者"},{"title":"vue项目中生成唯一id——nanoid","slug":"vue项目中生成唯一id——nanoid","date":"2022-11-01T01:40:09.000Z","updated":"2022-11-01T01:40:09.000Z","comments":true,"path":"2022/11/01/vue项目中生成唯一id——nanoid/","link":"","permalink":"http://example.com/2022/11/01/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80id%E2%80%94%E2%80%94nanoid/","excerpt":"","text":"第一步：npm i nanoid 第二步：在需要唯一id的页面引入nanoid: import { nanoid } from ‘nanoid’ 第三步：nanoid作为函数被引入，直接调用函数即可","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"nanoid","slug":"nanoid","permalink":"http://example.com/tags/nanoid/"}],"author":"作者"},{"title":"如何在Windows下搭建WordPress博客站点","slug":"如何在Windows下搭建WordPress博客站点","date":"2022-10-30T11:52:28.000Z","updated":"2022-10-30T11:52:28.000Z","comments":true,"path":"2022/10/30/如何在Windows下搭建WordPress博客站点/","link":"","permalink":"http://example.com/2022/10/30/%E5%A6%82%E4%BD%95%E5%9C%A8Windows%E4%B8%8B%E6%90%AD%E5%BB%BAWordPress%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9/","excerpt":"","text":"[TOC] 概述本教程是《Windows下如何使用cpolar搭建Web站点系列》第4篇，前面已经介绍cpolar的安装，搭建了一个简单的演示站点，并且配置好了开机自启动。如果您没看过之前的教程，请先阅读《第一篇》。 本篇继续，搭建一个真正有用的Web站点，您可以用它来撰写博客、搭建您自己的企业站点，外贸站点等，并且发布至公网上。 前置准备查看当前WordPress版本的组件依赖需求 访问WordPress官网: wordpress.org&#x2F;download&#x2F; 在本教程发布时，当前最新的WordPress版本为5.8.2 下面红框位置显示，它需要依赖PHP 7.4 我们对比一下PHPStudy里的组件版本，当前PHP 7.4没有安装，后面需要安装一下。其它的我们都已经满足。 接下来，我们要做如下操作： 安装数据库管理工具 创建一个数据库 安装PHP 7.4 为WordPress新创建一个站点 安装与配置WordPress 1 安装数据库管理工具1.1 安装图形图数据库管理工具，SQL_Front在PHPStudy面板-软件管理-找到SQL_Front，点击安装按钮 安装后，点击管理按钮，打开数据库工具 选择localhost本地数据库，点击打开按钮 如有错误提示，点击确认，忽略即可,不影响。 2 创建一个新数据库2.1 创建数据库在localhost上点击右键，选择新建–数据库 数据库名称，可以自定义,这里填写如下： 数据库名称: wordpress 字符集: utf8mb4 字符集校队: utf8mb4_unicode_ci 之后，点击确认按钮。 数据库创建成功。 2.2 为数据库创建一个用户为了安全起见，我们为wordpress数据库，单独创建一个的用户名和密码，用于管理它，而不是使用root账号。 在用户点击右键，弹出菜单，选择 新建–用户 本例中，我们创建一个简单用户名user1，密码:12345678 注：本例是为了教学演示，用户名及密码简单，您在生产环境，应该创建更复杂的用户名和密码。 选择权限栏，为用户添加权限，在赋予权限选择数据库，并指定wordpress数据库，然后在右侧勾选所有权限。该用户只能控制wordpress数据库，而不能读写其它数据库。 选择配置好的wordpress权限，点击确定按钮。 添加好以后，如下图所示： 3 安装PHP7.4在PHPStudy管理面板–软件管理– php7.4.3nts，点击安装。 4. 创建一个新站点4.1 创建站点根目录我们在D盘，创建一个websites目录，再在下面创建一个site1目录，作为本次wordpress站点的根目录，如图： 4.2 访问WordPress官网，下载最新版本的压缩包下载地址: wordpress.org&#x2F;latest.zip 下载后解压，将所有文件内容，复制 粘贴到site1目录下，如下图： 4.3 创建新Web站点在PHPStudy面板–网站–点击创建网站按钮 按下图配置： 我们在本机，8080端口上，创建了一个新站点。如下图： 4.4 打开浏览器测试一下http://localhost:8080/ ,显示如下图，证明新网站创建成功。 5 cpolar配置如果之前没有安装过cpolar，请参考这个系列的《第一篇》教程。 5.1 在后台预留一个二级子域名cpolar后台–预留–保留二级子域名，本例中: 二级子域名: dev10 (您可以配置成不同的) 地区: 选择 China VIP（cn_vip） 描述: wordpress （可选） 如下图： 5.2 修改cpolar配置文件，添加一个隧道指向8080端口使用VS Code，打开cpolar配置文件 本例中,配置文件的路径在：C:\\Users\\michael.cpolar\\cpolar.yml 打开后的样式： 我们在配置文件的最后面，添加一个新的隧道 隧道名称为wordpress,指向8080端口，二级子域名为dev10，地区是cn_vip，如下： 123456wordpress: proto: http addr: &quot;8080&quot; subdomain: dev10 #这里改为您自己的二级子域名 region: cn_vip复制代码 修改后的配置文件，如下图： 注意：ymal格式是缩进敏感的，注意wordpress隧道的缩进与上面演示站点website的缩进是一致的。 如果缩进不一致，请适当调整。 修改后，保存文件。 5.3 验证cpolar配置文件是否正确以管理员方式打开命令行窗口 关掉后台的cpolar服务 12cpolar service stop复制代码 在前台运行cpolar，子命令使用start-all，意思是启动配置文件所有隧道，以测试配置文件是否正确。 12cpolar start-all复制代码 如显示下图，则说明配置文件正确。 按CTRL+C，关掉前台cpolar 启动后台cpolar服务 12cpolar service start复制代码 我们打开浏览器，测试一下 dev10.vip.cpolar.cn&#x2F; 如同样显示下图，则说明公网域名配置成功了。 6 WordPress初始化配置6.1 WordPress初始化设置现在开始进行WordPress初始化设置 选择中文简体，按继续按钮 这里使用前面创建的数据库账号和密码 这里可以根据您的喜欢自定义配置，点击安装WordPress 安装成功后，跳转到Wordpress的后台控制面板 安装WordPress成功！ 6.2 为WordPress定制主题WordPress是非常可定制的。通过在页面顶部的 WordPress 横幅中单击您的站点名称（当您登录时），您将被带到仪表板。从那里，您可以更改主题、添加页面和帖子、编辑菜单、添加插件等等。这只是在 Raspberry Pi 的 Web 服务器上设置一些有趣的东西的品尝器。 下面，我们更换一个主题试试。 WordPress仪表盘–&gt;外观–&gt;主题 点击安装主题按钮，如下图： 点击热门，选择一个自己喜欢的主题，点击安装按钮 主题安装成功后，点击启用按钮。 新开一个浏览器窗口，打开 dev10.vip.cpolar.cn&#x2F; 我们来浏览一下新主题的效果。 恭喜！我们的新博客站点，已经基本创建成功了！ 6.4 安装WordPress相对URL插件（必需）您必须确保WordPress发布为相对URL，否则使用https地址访问时将出现错误。 您可以通过安装以下插件之一来完成此操作 插件： odt-relative-urls relative-url root-relative-urls 本例中，我们安装Relative URL插件： 登录WordPress仪表盘–&gt;插件–&gt;安装插件 在关键词搜索栏输入Relative URL 回车 找到插件后点击现在安装按钮 当安装成功后，点击启用按钮，激活插件。 修改config.php配置您必须确保Wordpress了解它是为了通过隧道主机名提供服务。 您可以通过修改wp-config.php来配置Wordpress以包含以下行： 123define(&#x27;WP_SITEURL&#x27;, &#x27;http://&#x27; . $_SERVER[&#x27;HTTP_HOST&#x27;]);define(&#x27;WP_HOME&#x27;, &#x27;http://&#x27; . $_SERVER[&#x27;HTTP_HOST&#x27;]);复制代码 修改wp-config.php文件 打开网站根目录下的wp-config.php文件，添加上面的项，然后保存。 配置好以后如图： 现在，我们的博客站点可以被公网正常访问啦！让我们看看效果： 使用https地址访问: dev10.vip.cpolar.cn&#x2F; 看着红框里美丽的小锁头，现在心情好多了。^ ^ 我们已经成功搭建起了WordPress站点。 总结：我们创建了一个新Web站点，安装配置了wordpress最新版本，并且配置了公网隧道，二级子域名，并且给新站点配置了主题样式，您拥有了一个属于自己的博客站点，可以写博客，开启自己的自媒体之旅。 在后面的教程里，我们会继续完善WordPress站点的配置，为其配置SSL，如果您喜欢，请分享给好友，并且关注后续章节。 欢迎进一步了解更多关于cpolar的讯息~ 链接：https://juejin.cn/post/7072560430949859364来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"博客","slug":"博客","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://example.com/tags/WordPress/"}],"author":"作者"},{"title":"使用nvm管理node版本","slug":"使用nvm管理node版本","date":"2022-10-29T07:50:04.000Z","updated":"2022-10-29T07:50:04.000Z","comments":true,"path":"2022/10/29/使用nvm管理node版本/","link":"","permalink":"http://example.com/2022/10/29/%E4%BD%BF%E7%94%A8nvm%E7%AE%A1%E7%90%86node%E7%89%88%E6%9C%AC/","excerpt":"","text":"nvm安装及配置使用 nvm是node版本管理器，用于管理多个活动Node.js版本的简单bash脚本，让我们可以设置默认node版本，并在不同开发环境中切换不同版本。 安装nvm1.打开下载地址，下载对应安装包。 2.双击安装文件 nvm-setup.exe，同意协议点击下一步 3.选择nvm安装路径 4.选择nodejs路径 5.点击安装按钮进行安装 6.安装完毕打开控制台，输入nvm，安装成功则如下显示。 解决nvm安装node和npm太慢 nvm默认node镜像源是https://nodejs.org/dist，从默认的镜像缘源下载会很慢，所以可以通过更换镜像源加快下载 1.找到之前安装nvm的文件夹目录，打开settings.txt文件 2.新增两行配置，更换node和npm的下载源为淘宝镜像源 123node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/复制代码 使用nvm安装Node.js1.终端输入nvm ls查看已安装的node.js版本。*选择的为当前使用的版本。 1nvm ls 2.使用nvm安装指定版本node.js 1nvm install 14.17.6 如下图所示说明安装指定版本的node.js和npm成功 在nvm的文件夹目录新增了指定版本的文件夹 文件夹里有已经安装好的node、npm和npx的包 3.使用指定版本node.js，查看node和npm版本。 1nvm use 14.17.6 4.卸载指定版本node.js 1nvm uninstall 14.17.6 命令提示说明 nvm arch [32|64]：显示node是运行在32位还是64位。 nvm current： 显示活动版本。 nvm install &lt;version&gt; [arch]：安装node， version是特定版本也可以是最新稳定版本latest。可选参数arch指定安装32位还是64位版本，默认是系统位数。可以添加–insecure绕过- 远程服务器的SSL。 nvm list [available]：显示已安装的列表。可选参数available，显示可安装的所有版本。list可简化为ls。 nvm on：开启node.js版本管理。 nvm off：关闭node.js版本管理。 nvm proxy [url]：设置下载代理。不加可选参数url，显示当前代理。将url设置为none则移除代理。 nvm uninstall &lt;version&gt;：卸载指定版本node。 nvm use [version] [arch]：使用制定版本node。可指定32&#x2F;64位。 nvm root [path]：设置存储不同版本node的目录。如果未设置，默认使用当前目录。 nvm version：显示nvm版本。version可简化为v。 nvm node_mirror [node_mirror_url]：设置node镜像。默认是https://nodejs.org/dist/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。 nvm npm_mirror [npm_mirror_url]：设置npm镜像。默认是https://github.com/npm/cli/archive/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。 安装yarn1.使用已经安装好的npm来安装yarn 1npm install yarn -g 2.查看yarn版本 1yarn -v 3.使用nvm进行node版本管理后，在每个node版本下都需要安装yarn，安装后指定版本文件夹会新增yarn文件 设置npm和yarn的淘宝镜像 淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)大幅提升包的下载速度，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。 1.设置npm淘宝镜像 1npm config set registry http://registry.npm.taobao.org/ 2.设置yarn淘宝镜像 1yarn config set registry http://registry.npm.taobao.org/ 3.查询当前配置的镜像 12npm get registryyarn config get registry","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"nvm","slug":"nvm","permalink":"http://example.com/tags/nvm/"}],"author":"作者"},{"title":"临时邮箱","slug":"临时邮箱","date":"2022-10-27T06:37:43.000Z","updated":"2022-10-27T06:37:43.000Z","comments":true,"path":"2022/10/27/临时邮箱/","link":"","permalink":"http://example.com/2022/10/27/%E4%B8%B4%E6%97%B6%E9%82%AE%E7%AE%B1/","excerpt":"","text":"临时邮箱24小时邮箱：http://24mail.chacuo.net60分钟邮箱：https://www.guerrillamail.com/zh/10 分钟邮箱：https://linshiyouxiang.net/10 分钟邮箱：http://www.bccto.me/10 分钟邮箱：https://temp-mail.org/zh/10 分钟邮箱：https://10minutemail.net/?lang=zh-cn10 分钟邮箱：http://10minutemail.com/10MinuteMail/index.html10 分钟邮箱：https://9em.org/10分钟邮箱：https://mailtemp.net10分钟邮箱：https://email10min.com30分钟邮箱： https://shorttimemail.com/zh-Hans60 分钟邮箱：https://www.moakt.com/zh/mail60 分钟邮箱：http://www.nowmymail.com60 分钟邮箱：http://www.incognitomail.com/24 小时邮箱：http://24mail.chacuo.net/5日邮箱：http://www.yopmail.com/zh/最多一个月：http://www.jetable.org/zh/index时间不知：http://www.mailinator.comMailDrop：https://maildrop.cc/匿名发信：https://eskiimo.com/大概24小时：https://tempmail.altmails.com小鸟临时邮箱：http://www.5-mail.com10 分钟一次性电子邮件：https://10minemail.com/zh/10分钟临时一次性电子邮件：https://www.crazymailing.com/zh/ 如果有想保存的邮件可以转发到真实邮箱一次性臨時電子郵件：https://www.mohmal.com/zhEmailonDeck免费临时电子邮件：https://www.emailondeck.com/zh-cn/TrashSpam - 临时一次性电子邮件：https://trashspam.com/cn/ 有效期：1天 注册时不想泄露自己邮箱时可用https://mail.td/zhhttps://mail.tm/zh/https://spambox.xyz/https://maildrop.cc/https://www.mohmal.com/zhhttp://24mail.chacuo.net/https://www.nowmymail.com/https://www.crazymailing.com/loginhttps://10minutemail.com/http://www.mytrashmail.com/https://www.clipmails.com/https://tempmail.altmails.com/https://mailpoof.com/zhhttps://www.gmailnator.com/https://www.disposablemail.com/https://www.mohmal.com/zhhttps://www.emailondeck.com/http://www.tempinbox.com/https://www.guerrillamail.com/https://dropmail.me/zh/https://www.moakt.com/https://mailsac.com/https://www.nowmymail.com/https://www.guerrillamail.com/zh/https://www.linshi-email.com/https://www.snapmail.cc/#/https://mail.mjj.edu.ge/https://www.20minutemail.com/#tophttp://24mail.chacuo.net/enushttps://www.8164.cc/#/emailList/allhttp://mailnesia.com/https://ihotmails.com/https://temp-mail.io/zh 2022.9.20新增 EduMail是一个了临时邮箱生成器，主要免费提供在线临时邮箱的服务，通常，网站和在线服务要求提供有效的电子邮件地址来注册、访问和查看或接收内容等。然而，其中一些网站最终可能会使用我们的电子邮件地址发送垃圾邮件或者过多暴露邮箱地址，造成一定程度的隐私问题，那么就可以试试使用临时邮箱,临时电子邮件来解决这个问题。 https://edumail.icu/mailbox 2022.9.29新增 InstAddr是一个提供免费一次性邮箱的网站，和临时邮箱差不多，允许用户同时拥有无限数量的电子邮件地址，没有任何到期日期。各项功能均可免费使用，无需注册即可使用，支持收发邮件，体验了一下发现，支持的邮箱后缀比较多，还有域名邮箱等等，支持用来注册推特账或其他服务，网站还提供移动应用程序和浏览器插件，非常不错。 https://m.kuku.lu/ 2022.10.16日新增 一款免费的临时教育邮箱网站，可在有教育邮箱注册优惠的平台使用。【网站网址】https://etempmail.com/","categories":[{"name":"邮箱","slug":"邮箱","permalink":"http://example.com/categories/%E9%82%AE%E7%AE%B1/"}],"tags":[{"name":"email","slug":"email","permalink":"http://example.com/tags/email/"}],"author":"作者"},{"title":"关于.eslintrc.js的一些检查配置","slug":"关于-eslintrc-js的一些检查配置","date":"2022-10-22T14:52:54.000Z","updated":"2022-10-22T14:52:54.000Z","comments":true,"path":"2022/10/22/关于-eslintrc-js的一些检查配置/","link":"","permalink":"http://example.com/2022/10/22/%E5%85%B3%E4%BA%8E-eslintrc-js%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A3%80%E6%9F%A5%E9%85%8D%E7%BD%AE/","excerpt":"","text":"关于.eslintrc.js的一些检查配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241module.exports = &#123; root: true, env: &#123; node: true &#125;, extends: [&quot;plugin:vue/essential&quot;, &quot;@vue/prettier&quot;], rules: &#123; &quot;no-console&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;error&quot; : &quot;off&quot;, &quot;no-debugger&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;error&quot; : &quot;off&quot;, &quot;prettier/prettier&quot;: [ &quot;error&quot;, &#123; // tab缩进大小,默认为2 &quot;tabWidth&quot;: 2, // 使用tab缩进，默认false &quot;useTabs&quot;: false, // 使用分号, 默认true &quot;semi&quot;: false, // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号) &quot;singleQuote&quot;: true, // 行尾逗号,默认none,可选 none|es5|all // es5 包括es5中的数组、对象 // all 包括函数对象等所有可选 &quot;trailingComma&quot;: &#x27;none&#x27;, // 对象中的空格 默认true // true: &#123; foo: bar &#125; // false: &#123;foo: bar&#125; &quot;bracketSpacing&quot;: true, // JSX标签闭合位置 默认false // false: &lt;div // className=&quot;&quot; // style=&#123;&#123;&#125;&#125; // &gt; // true: &lt;div // className=&quot;&quot; // style=&#123;&#123;&#125;&#125; &gt; &quot;jsxBracketSameLine&quot;: false, // 箭头函数参数括号 默认avoid 可选 avoid| always // avoid 能省略括号的时候就省略 例如x =&gt; x // always 总是有括号 &quot;arrowParens&quot;: &#x27;always&#x27; &#125; ], &quot;no-alert&quot;: 0, //禁止使用alert confirm prompt &quot;no-array-constructor&quot;: 2, //禁止使用数组构造器 &quot;no-bitwise&quot;: 0, //禁止使用按位运算符 &quot;no-caller&quot;: 1, //禁止使用arguments.caller或arguments.callee &quot;no-catch-shadow&quot;: 2, //禁止catch子句参数与外部作用域变量同名 &quot;no-class-assign&quot;: 2, //禁止给类赋值 &quot;no-cond-assign&quot;: 2, //禁止在条件表达式中使用赋值语句 &quot;no-console&quot;: 0, //禁止使用console &quot;no-const-assign&quot;: 2, //禁止修改const声明的变量 &quot;no-constant-condition&quot;: 2, //禁止在条件中使用常量表达式 if(true) if(1) &quot;no-continue&quot;: 0, //禁止使用continue &quot;no-control-regex&quot;: 2, //禁止在正则表达式中使用控制字符 &quot;no-debugger&quot;: 2, //禁止使用debugger &quot;no-delete-var&quot;: 2, //不能对var声明的变量使用delete操作符 &quot;no-div-regex&quot;: 1, //不能使用看起来像除法的正则表达式/=foo/ &quot;no-dupe-keys&quot;: 2, //在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125; &quot;no-dupe-args&quot;: 2, //函数参数不能重复 &quot;no-duplicate-case&quot;: 2, //switch中的case标签不能重复 &quot;no-else-return&quot;: 2, //如果if语句里面有return,后面不能跟else语句 &quot;no-empty&quot;: 2, //块语句中的内容不能为空 &quot;no-empty-character-class&quot;: 2, //正则表达式中的[]内容不能为空 &quot;no-empty-label&quot;: 0, //禁止使用空label &quot;no-eq-null&quot;: 2, //禁止对null使用==或!=运算符 &quot;no-eval&quot;: 1, //禁止使用eval &quot;no-ex-assign&quot;: 2, //禁止给catch语句中的异常参数赋值 &quot;no-extend-native&quot;: 2, //禁止扩展native对象 &quot;no-extra-bind&quot;: 2, //禁止不必要的函数绑定 &quot;no-extra-boolean-cast&quot;: 2, //禁止不必要的bool转换 &quot;no-extra-parens&quot;: 2, //禁止非必要的括号 &quot;no-extra-semi&quot;: 2, //禁止多余的冒号 &quot;no-fallthrough&quot;: 1, //禁止switch穿透 &quot;no-floating-decimal&quot;: 2, //禁止省略浮点数中的0 .5 3. &quot;no-func-assign&quot;: 2, //禁止重复的函数声明 &quot;no-implicit-coercion&quot;: 1, //禁止隐式转换 &quot;no-implied-eval&quot;: 2, //禁止使用隐式eval &quot;no-inline-comments&quot;: 0, //禁止行内备注 &quot;no-inner-declarations&quot;: [2, &quot;functions&quot;], //禁止在块语句中使用声明（变量或函数） &quot;no-invalid-regexp&quot;: 2, //禁止无效的正则表达式 &quot;no-invalid-this&quot;: 2, //禁止无效的this，只能用在构造器，类，对象字面量 &quot;no-irregular-whitespace&quot;: 2, //不能有不规则的空格 &quot;no-iterator&quot;: 2, //禁止使用__iterator__ 属性 &quot;no-label-var&quot;: 2, //label名不能与var声明的变量名相同 &quot;no-labels&quot;: 2, //禁止标签声明 &quot;no-lone-blocks&quot;: 2, //禁止不必要的嵌套块 &quot;no-lonely-if&quot;: 2, //禁止else语句内只有if语句 &quot;no-loop-func&quot;: 1, //禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以） &quot;no-mixed-requires&quot;: [0, false], //声明时不能混用声明类型 &quot;no-mixed-spaces-and-tabs&quot;: [2, false], //禁止混用tab和空格 &quot;linebreak-style&quot;: [0, &quot;windows&quot;], //换行风格 &quot;no-multi-spaces&quot;: 1, //不能用多余的空格 &quot;no-multi-str&quot;: 2, //字符串不能用\\换行 &quot;no-multiple-empty-lines&quot;: [1, &#123; &quot;max&quot;: 2 &#125;], //空行最多不能超过2行 &quot;no-native-reassign&quot;: 2, //不能重写native对象 &quot;no-negated-in-lhs&quot;: 2, //in 操作符的左边不能有! &quot;no-nested-ternary&quot;: 0, //禁止使用嵌套的三目运算 &quot;no-new&quot;: 1, //禁止在使用new构造一个实例后不赋值 &quot;no-new-func&quot;: 1, //禁止使用new Function &quot;no-new-object&quot;: 2, //禁止使用new Object() &quot;no-new-require&quot;: 2, //禁止使用new require &quot;no-new-wrappers&quot;: 2, //禁止使用new创建包装实例，new String new Boolean new Number &quot;no-obj-calls&quot;: 2, //不能调用内置的全局对象，比如Math() JSON() &quot;no-octal&quot;: 2, //禁止使用八进制数字 &quot;no-octal-escape&quot;: 2, //禁止使用八进制转义序列 &quot;no-param-reassign&quot;: 2, //禁止给参数重新赋值 &quot;no-path-concat&quot;: 0, //node中不能使用__dirname或__filename做路径拼接 &quot;no-plusplus&quot;: 0, //禁止使用++，-- &quot;no-process-env&quot;: 0, //禁止使用process.env &quot;no-process-exit&quot;: 0, //禁止使用process.exit() &quot;no-proto&quot;: 2, //禁止使用__proto__属性 &quot;no-redeclare&quot;: 2, //禁止重复声明变量 &quot;no-regex-spaces&quot;: 2, //禁止在正则表达式字面量中使用多个空格 /foo bar/ &quot;no-restricted-modules&quot;: 0, //如果禁用了指定模块，使用就会报错 &quot;no-return-assign&quot;: 1, //return 语句中不能有赋值表达式 &quot;no-script-url&quot;: 0, //禁止使用javascript:void(0) &quot;no-self-compare&quot;: 2, //不能比较自身 &quot;no-sequences&quot;: 0, //禁止使用逗号运算符 &quot;no-shadow&quot;: 2, //外部作用域中的变量不能与它所包含的作用域中的变量或参数同名 &quot;no-shadow-restricted-names&quot;: 2, //严格模式中规定的限制标识符不能作为声明时的变量名使用 &quot;no-spaced-func&quot;: 2, //函数调用时 函数名与()之间不能有空格 &quot;no-sparse-arrays&quot;: 2, //禁止稀疏数组， [1,,2] &quot;no-sync&quot;: 0, //nodejs 禁止同步方法 &quot;no-ternary&quot;: 0, //禁止使用三目运算符 &quot;no-trailing-spaces&quot;: 1, //一行结束后面不要有空格 &quot;no-this-before-super&quot;: 0, //在调用super()之前不能使用this或super &quot;no-throw-literal&quot;: 2, //禁止抛出字面量错误 throw &quot;error&quot;; &quot;no-undef&quot;: 1, //不能有未定义的变量 &quot;no-undef-init&quot;: 2, //变量初始化时不能直接给它赋值为undefined &quot;no-undefined&quot;: 2, //不能使用undefined &quot;no-unexpected-multiline&quot;: 2, //避免多行表达式 &quot;no-underscore-dangle&quot;: 1, //标识符不能以_开头或结尾 &quot;no-unneeded-ternary&quot;: 2, //禁止不必要的嵌套 var isYes = answer === 1 ? true : false; &quot;no-unreachable&quot;: 2, //不能有无法执行的代码 &quot;no-unused-expressions&quot;: 2, //禁止无用的表达式 &quot;no-unused-vars&quot;: [2, &#123; &quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot; &#125;], //不能有声明后未被使用的变量或参数 &quot;no-use-before-define&quot;: 2, //未定义前不能使用 &quot;no-useless-call&quot;: 2, //禁止不必要的call和apply &quot;no-void&quot;: 2, //禁用void操作符 &quot;no-var&quot;: 0, //禁用var，用let和const代替 &quot;no-warning-comments&quot;: [1, &#123; &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; &#125;], //不能有警告备注 &quot;no-with&quot;: 2, //禁用with &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;], //是否允许非空数组里面有多余的空格 &quot;arrow-parens&quot;: 0, //箭头函数用小括号括起来 &quot;arrow-spacing&quot;: 0, //=&gt;的前/后括号 &quot;accessor-pairs&quot;: 0, //在对象中使用getter/setter &quot;block-scoped-var&quot;: 0, //块语句中使用var &quot;brace-style&quot;: [1, &quot;1tbs&quot;], //大括号风格 &quot;callback-return&quot;: 1, //避免多次调用回调什么的 &quot;camelcase&quot;: 2, //强制驼峰法命名 &quot;comma-dangle&quot;: [2, &quot;never&quot;], //对象字面量项尾不能有逗号 &quot;comma-spacing&quot;: 0, //逗号前后的空格 &quot;comma-style&quot;: [2, &quot;last&quot;], //逗号风格，换行时在行首还是行尾 &quot;complexity&quot;: [0, 11], //循环复杂度 &quot;computed-property-spacing&quot;: [0, &quot;never&quot;], //是否允许计算后的键名什么的 &quot;consistent-return&quot;: 0, //return 后面是否允许省略 &quot;consistent-this&quot;: [2, &quot;that&quot;], //this别名 &quot;constructor-super&quot;: 0, //非派生类不能调用super，派生类必须调用super &quot;curly&quot;: [2, &quot;all&quot;], //必须使用 if()&#123;&#125; 中的&#123;&#125; &quot;default-case&quot;: 0, //switch语句最后必须有default &quot;dot-location&quot;: 0, //对象访问符的位置，换行的时候在行首还是行尾 &quot;dot-notation&quot;: [0, &#123; &quot;allowKeywords&quot;: true &#125;], //避免不必要的方括号 &quot;eol-last&quot;: 0, //文件以单一的换行符结束 &quot;eqeqeq&quot;: 2, //必须使用全等 &quot;func-names&quot;: 0, //函数表达式必须有名字 &quot;func-style&quot;: [0, &quot;declaration&quot;], //函数风格，规定只能使用函数声明/函数表达式 &quot;generator-star-spacing&quot;: 0, //生成器函数*的前后空格 &quot;guard-for-in&quot;: 0, //for in循环要用if语句过滤 &quot;handle-callback-err&quot;: 0, //nodejs 处理错误 &quot;id-length&quot;: 0, //变量名长度 &quot;indent&quot;: [2, 2], //缩进风格 &quot;init-declarations&quot;: 0, //声明时必须赋初值 &quot;key-spacing&quot;: [0, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;], //对象字面量中冒号的前后空格 &quot;lines-around-comment&quot;: 0, //行前/行后备注 &quot;max-depth&quot;: [0, 4], //嵌套块深度 &quot;max-len&quot;: [0, 80, 4], //字符串最大长度 &quot;max-nested-callbacks&quot;: [0, 2], //回调嵌套深度 &quot;max-params&quot;: [0, 3], //函数最多只能有3个参数 &quot;max-statements&quot;: [0, 10], //函数内最多有几个声明 &quot;new-cap&quot;: 2, //函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用 &quot;new-parens&quot;: 2, //new时必须加小括号 &quot;newline-after-var&quot;: 2, //变量声明后是否需要空一行 &quot;object-curly-spacing&quot;: [0, &quot;never&quot;], //大括号内是否允许不必要的空格 &quot;object-shorthand&quot;: 0, //强制对象字面量缩写语法 &quot;one-var&quot;: 0, //连续声明 &quot;operator-assignment&quot;: [0, &quot;always&quot;], //赋值运算符 += -=什么的 &quot;operator-linebreak&quot;: [2, &quot;after&quot;], //换行时运算符在行尾还是行首 &quot;padded-blocks&quot;: 0, //块语句内行首行尾是否要空行 &quot;prefer-const&quot;: 0, //首选const &quot;prefer-spread&quot;: 0, //首选展开运算 &quot;prefer-reflect&quot;: 0, //首选Reflect的方法 &quot;quotes&quot;: [1, &quot;single&quot;], //引号类型 `` &quot;&quot; &#x27;&#x27; &quot;quote-props&quot;: [0, &quot;always&quot;], //对象字面量中的属性名是否强制双引号 &quot;radix&quot;: 2, //parseInt必须指定第二个参数 &quot;id-match&quot;: 0, //命名检测 &quot;require-yield&quot;: 0, //生成器函数必须有yield &quot;semi&quot;: [0, &quot;always&quot;], //语句强制分号结尾 &quot;semi-spacing&quot;: [0, &#123; &quot;before&quot;: false, &quot;after&quot;: true &#125;], //分号前后空格 &quot;sort-vars&quot;: 0, //变量声明时排序 &quot;space-after-keywords&quot;: [0, &quot;always&quot;], //关键字后面是否要空一格 &quot;space-before-blocks&quot;: [0, &quot;always&quot;], //不以新行开始的块&#123;前面要不要有空格 &quot;space-before-function-paren&quot;: [0, &quot;always&quot;], //函数定义时括号前面要不要有空格 &quot;space-in-parens&quot;: [0, &quot;never&quot;], //小括号里面要不要有空格 &quot;space-infix-ops&quot;: 0, //中缀操作符周围要不要有空格 &quot;space-return-throw-case&quot;: 0, //return throw case后面要不要加空格 &quot;space-unary-ops&quot;: [0, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;], //一元运算符的前/后要不要加空格 &quot;spaced-comment&quot;: 0, //注释风格要不要有空格什么的 &quot;strict&quot;: 2, //使用严格模式 &quot;use-isnan&quot;: 2, //禁止比较时使用NaN，只能用isNaN() &quot;valid-jsdoc&quot;: 0, //jsdoc规则 &quot;valid-typeof&quot;: 2, //必须使用合法的typeof的值 &quot;vars-on-top&quot;: 2, //var必须放在作用域顶部 &quot;wrap-iife&quot;: [2, &quot;inside&quot;], //立即执行函数表达式的小括号风格 &quot;wrap-regex&quot;: 0, //正则表达式字面量用小括号包起来 &quot;yoda&quot;: [2, &quot;never&quot;] //禁止尤达条件 &#125;, parserOptions: &#123; parser: &quot;babel-eslint&quot; &#125;&#125;; 来源于简书：https://www.jianshu.com/p/7dec56e7c132 初始时间：2019.04.21 22:56:17","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"作者"},{"title":"vite启动后不能正常访问服务","slug":"vite启动后不能正常访问服务","date":"2022-10-16T05:00:43.000Z","updated":"2022-10-16T05:00:43.000Z","comments":true,"path":"2022/10/16/vite启动后不能正常访问服务/","link":"","permalink":"http://example.com/2022/10/16/vite%E5%90%AF%E5%8A%A8%E5%90%8E%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"起因当使用 Vite 构建项目后，需要通过局域网中的电脑或手机访问服务调试时，发现通过 IP + 端口无法访问。 问题重现当运行 npm run dev | serve 命令时，会显示一下内容。 1234567vite-vue@0.0.0 serve /Users/UserName/Workspace/vue-vitevite | vite preview vite v2.3.7 build preview server running at: &gt; Local: http://localhost:3000 | 5000/ &gt; Network: use `--host` to expose 问题原因当 局域网 中另一台设备需要访问该服务时，必须通过本机 IP + 端口 访问。尝试访问后，发现找不到这个服务，原因是 没有 将服务暴露在网络中 解决方法在控制台会显示 user --host to expose（使用 –host 暴露网络）通常我们都会在npm run dev | serve 的后边拼接上 --host 执行 npm run dev | serve --host 后控制台还是会显示 Netvork: user --host to expose 1234server.host类型： string默认： ‘127.0.0.1’指定服务器应该监听哪个 IP 地址。 如果将此设置为 0.0.0.0 将监听所有地址，包括局域网和公网地址。 于是通过查阅 文档 发现了三种解决方案： 1.修改 vite.config.js 配置在根目录下的 vite.config.js 文件中添加以下内容(第一种不一定有效，试用其他方法) 123456789101112import vue from &#x27;@vitejs/plugin-vue&#x27;/** * https://vitejs.dev/config/ * @type &#123;import(&#x27;vite&#x27;).UserConfig&#125; */ export default &#123; plugins: [vue()], server: &#123; // ← ← ← ← ← ← host: &#x27;0.0.0.0&#x27; // ← 新增内容 ← &#125; // ← ← ← ← ← ← &#125; 2.通过 Vite CLI 配置执行 npx vite --host 0.0.0.0 命令后，就可以通过 http://10.56.116.128:3000/ 访问了 123456vite v2.3.7 dev server running at:&gt; Local: http://localhost:3000/&gt; Network: http://10.56.116.128:3000/ready in 301ms. 3.修改 npm 脚本修改 package.json 文件中 scripts 节点下的脚本，如下： 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite --host 0.0.0.0&quot;, &quot;build&quot;: &quot;vite build&quot;, &quot;serve&quot;: &quot;vite preview --host 0.0.0.0&quot;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vite","slug":"vite","permalink":"http://example.com/tags/vite/"}],"author":"作者"},{"title":"删除电脑浏览记录","slug":"如何删除电脑上最近浏览记录","date":"2022-10-15T05:30:41.000Z","updated":"2022-10-15T05:30:41.000Z","comments":true,"path":"2022/10/15/如何删除电脑上最近浏览记录/","link":"","permalink":"http://example.com/2022/10/15/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E7%94%B5%E8%84%91%E4%B8%8A%E6%9C%80%E8%BF%91%E6%B5%8F%E8%A7%88%E8%AE%B0%E5%BD%95/","excerpt":"","text":"我们在长时间操作电脑的过程中，系统都会记录用户浏览的历史，一天下来电脑可能产生几万条记录,这些记录有些会涉及到个人的隐私，因此许多用户就想要在关闭电脑前将浏览记录进行删除，那么怎么删除电脑最近浏览记录呢？这里小编就来教大家删除电脑上最近浏览记录操作方法。 具体方法 点击查看，打开资源管理器，点击查看。 点击选项，展开菜单后，点击右边的选项。 点击清除按钮，找到清除历史记录的选项即可。 以上就是删除电脑上最近浏览记录的操作方法了。","categories":[],"tags":[],"author":"作者"},{"title":"Win10自带软件卸载方法","slug":"win10卸载自带应用","date":"2022-10-14T17:40:33.000Z","updated":"2022-10-14T17:40:33.000Z","comments":true,"path":"2022/10/15/win10卸载自带应用/","link":"","permalink":"http://example.com/2022/10/15/win10%E5%8D%B8%E8%BD%BD%E8%87%AA%E5%B8%A6%E5%BA%94%E7%94%A8/","excerpt":"","text":"Win10自带软件卸载方法【详细教程】Win10自带软件怎么卸载 ?Win10一般都会在系统中预装不少软件，下面为大家带来了 Win10自带软件卸载教程 ，一起来看看。 使用命令卸载Win10内置软件 Win10系统内置的这些应用，可以通过“命令行”方式进行卸载的，支持卸载的应用以及对应的命令如下： 以管理员方式，打开 CMD 运行命名操作框，如，可以先按 Ctrl+X组合件，然后在搜索中，输入 CMD 然后在 命令提示符 中右键，点击以“管理员方式运行”，如下图所示。 打开命令运行窗口后，如果要卸载自带的 XBOX 应用，只要在命名窗口中，粘贴上命名 get-appxpackage Microsoft.XboxApp | remove-appxpackage 然后按下回车键(Enter)确认就可以了。 相关命令 闹钟时钟：get-appxpackage Microsoft.WindowsAlarms | remove-appxpackage 计算机：get-appxpackage Microsoft.WindowsCalculator | remove-appxpackage 相机：get-appxpackage Microsoft.WindowsCamera | remove-appxpackage Groove音乐：get-appxpackage Microsoft.ZuneMusic | remove-appxpackage 邮件和日历：get-appxpackage microsoft.windowscommunicationsapps | remove-appxpackage 地图：get-appxpackage Microsoft.WindowsMaps | remove-appxpackage 电影和电视：get-appxpackage Microsoft.ZuneVideo | remove-appxpackage Onenote：get-appxpackage Microsoft.Office.OneNote | remove-appxpackage 人脉：get-appxpackage Microsoft.People | remove-appxpackage 照片：get-appxpackage Microsoft.Windows.Photos | remove-appxpackage 语音录音机：get-appxpackage *Microsoft.WindowsSoundRecorder * | remove-appxpackage XBOX：get-appxpackage Microsoft.XboxApp | remove-appxpackage 注意事项 这种方法，需要是管理员账户下运行。 以上就是我介绍的 Win10自带软件怎么卸载 Win10自带软件卸载教程 ，希望对你有帮助。","categories":[{"name":"win10","slug":"win10","permalink":"http://example.com/categories/win10/"}],"tags":[],"author":"作者"},{"title":"添加相册","slug":"添加相册","date":"2022-10-06T15:10:15.000Z","updated":"2022-10-06T15:10:30.000Z","comments":true,"path":"2022/10/06/添加相册/","link":"","permalink":"http://example.com/2022/10/06/%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%86%8C/","excerpt":"","text":"本博客已经写好了相册功能，下面介绍一下相册的添加方法1.1 首先在 source-gallery 目录下面新建文件夹和 md 文件 文件夹名字随自己起名,根据个人情况而定 1.2 复制其他页面的内容粘贴到新建的 md 文档，相应的修改 title 和 galleryName,并关闭评论 galleryName： 一级相册的名字title: 二级相册页面的标题 1.3 style 是修改相册页面布局样式的， style 下面写上所要展示的图片 根据图片奇偶数调整每行展示几张图片,一行两个就选择 48%,三个就选择 32%。修改页面内的 style 样式不用重启服务，刷新即可看效果。 1.4 打开 gallery 下的根文件 index.md ,添加对应的一级封面 href 对应的是文件夹路径，跟你建的文件夹路径包保持一致。比如我的你比温柔更浪漫文件夹在晚晚晚儿呀的下面,对应的就是 &lt;a href=&quot;晚晚晚儿呀/你比温柔更浪漫&quot;&gt;。gallery 就是根目录。 img 展示的是一级封面，根据个人情况而定。 p 标签是对应相册的名字。 gallery-column:对应的是竖着一列的,有几个 column,一行(横着)就是展示几个。下面有几个 gallery-item,就是竖着几个展示。 div 上下之间不能有空行，否则会显示错误,字母会变灰色。 12345678910111213&lt;div class=&quot;gallery-column&quot;&gt; &lt;div class=&quot;gallery-item&quot;&gt; &lt;a href=&quot;晚晚晚儿呀/生活里被藏起来的温柔&quot;&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/txw1314/blog-img@main/晚晚晚儿呀/2022/1.13生活里被藏起来的温柔/202210061616952.jpg&quot;&gt; &lt;/a&gt; &lt;p&gt;生活里被藏起来的温柔&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;gallery-item&quot;&gt; &lt;a href=&quot;晚晚晚儿呀/你比温柔更浪漫&quot;&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/txw1314/blog-img@main/晚晚晚儿呀/2022/7.17你比温柔更浪漫/202210061643693.jpg&quot;&gt; &lt;/a&gt; &lt;p&gt;你比温柔更浪漫&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1.5 至此,相册添加完成,启动服务 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s即可观看效果,页面加载会缓慢,请耐心等待。最后,附上我的相册展示效果。","categories":[],"tags":[{"name":"gallery","slug":"gallery","permalink":"http://example.com/tags/gallery/"}],"author":"作者"},{"title":"github推送代码失败，提示August13","slug":"github/github推送代码失败，提示August13","date":"2022-10-01T17:23:52.000Z","updated":"2022-10-01T17:23:52.000Z","comments":true,"path":"2022/10/02/github/github推送代码失败，提示August13/","link":"","permalink":"http://example.com/2022/10/02/github/github%E6%8E%A8%E9%80%81%E4%BB%A3%E7%A0%81%E5%A4%B1%E8%B4%A5%EF%BC%8C%E6%8F%90%E7%A4%BAAugust13/","excerpt":"","text":"解决 remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead. 问题原因12345Logon failed, use ctrl+c to cancel basic credential prompt.remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.fatal: Authentication failed for &#x27;https://github.com/dream-code-kangli/online-learning.git/&#x27; 意思是自从 21 年 8 月 13 后不再支持用户名密码的方式验证了，需要创建个人访问令牌(personal access token)。 解决方法在 GitHub 上生成令牌，应用于所需的仓库中 1、点击 settings 2、点击右侧的 Developer settings 3、点击 Personal access tokens(个人访问令牌) 4、点击 Generate new token 5、设置 token 信息 根据所需过期时间，建议设置成永远，以免麻烦，建议所有选项都选上 点击 Generate token 生成令牌 6、得到生成的令牌 7、应用令牌将生成的令牌拷贝下来，记得保存，下次你就看不到了。 修改现有的 url 123git remote set-url origin https://&lt;your_token&gt;@github.com/&lt;USERNAME&gt;/&lt;REPO&gt;.giteg: git remote set-url origin http://ghp_tP3EgFiUWqeHL16Dmy1vkswpZVUUnO4RkQZ 2@github.com/txw1314/valinilla.git 将换成你自己得到的令牌。是你自己github的用户名，是你的项目名称 tip:&lt;&gt;不用带上，直接写自己的令牌和仓库名称就行了 然后再次执行 pull push 操作，输入你的gitbub用户名，密码是生成的令牌，大功告成。 h1,h2,h3,h4,h5,h6{ text-align:center; list-style: none; }","categories":[{"name":"github","slug":"github","permalink":"http://example.com/categories/github/"}],"tags":[{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"}],"author":"vanilla"},{"title":"vscode蓝色波浪线消除办法","slug":"study/vscode蓝色波浪线消除办法","date":"2022-10-01T16:30:46.000Z","updated":"2022-10-01T16:30:46.000Z","comments":true,"path":"2022/10/02/study/vscode蓝色波浪线消除办法/","link":"","permalink":"http://example.com/2022/10/02/study/vscode%E8%93%9D%E8%89%B2%E6%B3%A2%E6%B5%AA%E7%BA%BF%E6%B6%88%E9%99%A4%E5%8A%9E%E6%B3%95/","excerpt":"","text":"vscode蓝色波浪线不知道什么时候，我的vscode页面单词有蓝色波浪线了，提示：Unknow word，估计是版本更新之后什么配置的问题。这个蓝色波浪线不影响代码编辑和运行，就是看着碍眼，强迫症表示很难受。一直以来我都是点击修复来消除的，无意中看到一个方法，亲测有效特此记录。直接上图，按图步骤操作就行了 1.打开设置，输入code spell,出现如图所示 2.参看如图所示区域，spell:Enabled前面的勾取消掉即可，左下角的问题描述也全部消失了","categories":[{"name":"vscode","slug":"vscode","permalink":"http://example.com/categories/vscode/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://example.com/tags/vscode/"}],"author":"作者"},{"title":"使用github Actions自动化部署Hexo","slug":"hexo/使用Github Actions自动化部署Hexo","date":"2022-08-16T05:30:41.000Z","updated":"2024-09-04T08:33:54.232Z","comments":true,"path":"2022/08/16/hexo/使用Github Actions自动化部署Hexo/","link":"","permalink":"http://example.com/2022/08/16/hexo/%E4%BD%BF%E7%94%A8Github%20Actions%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2Hexo/","excerpt":"","text":"前言使用Github Actions自动化部署之后，可以脱离本地电脑，再也不用担心源码丢失。 新建私密仓库首先需要在GitHub上新建一个私密仓库，仓库名称随意，注意不要使用README初始化仓库。 生成公私秘钥对在mac的终端中执行： 12COPYssh-keygen -t rsa -C &quot;Github 的邮箱地址&quot; 之后生成的密钥默认存储在&#x2F;用户&#x2F;XXX&#x2F;.ssh&#x2F;目录下。 修改将Hexo博客的根目录复制到别的地方，显示隐藏文件夹，然后将里面的隐藏文件删除。之后将.ssh文件夹复制进去(这个可以不弄，我丢上去备份的)。再新建一个.github隐藏文件夹，里面新建一个workflows文件夹，在workflows里面新建一个自动化的配置文件hexoCI.yml其内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 自动化名称name: Hexo Blog CI # 触发条件on: push: branches: - main # 设置环境jobs: build: runs-on: ubuntu-latest steps: # check it to your workflow can access it # from: https://github.com/actions/checkout - name: Checkout Repository master branch uses: actions/checkout@master # from: https://github.com/actions/setup-node - name: Setup Node.js 15.x uses: actions/setup-node@master with: node-version: &quot;15.x&quot; - name: 安装Hexo run: | npm install hexo-cli -g npm install - name: 设置密钥 env: HEXO_DEPLOY_PRIVATE_KEY: $&#123;&#123; secrets.HEXO_DEPLOY_PRIVATE_KEY &#125;&#125; run: | mkdir -p ~/.ssh/ echo &quot;$HEXO_DEPLOY_PRIVATE_KEY&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts - name: 设置Git信息 run: | git config --global user.name &#x27;你GitHub的用户名&#x27; git config --global user.email &#x27;你GitHub的邮箱&#x27; - name: Hexo三连 run: | hexo clean hexo generate hexo deploy 修改博客根目录的_config.yml文件： 1234deploy: type: git repo: //这里改成ssh的链接 branch: master 打开node_modules文件夹，删除里面的hexo-deployer-git。 配置配置公钥：在github 网站–&gt;Settings–&gt;SSH and GPG keys里，名称为HEXO_DEPLOY_PRIVATE_KEY，内容为.ssh&#x2F;id_rsa.pub里的，注意复制的时候会多一个空格，把它删掉。配置私钥：在私有仓库的 Settings-&gt;Secrets 里，名称为HEXO_DEPLOY_PRIVATE_KEY，内容为.ssh&#x2F;id_rsa里的，注意复制的时候会多一个空格，把它删掉。之后在终端中cd切换至改好的hexo博客目录里，将博客推送到私有仓库。 123456git initgit add .git commit -m &quot;first commit&quot;git branch -M maingit remote add origin git@github.com:用户名/私有仓库名.gitgit push -u origin main 查看效果点击私有仓库的Action查看，运行正常再看一下博客内容有没有问题。我在Actions运行之后发现博客里的效果等有缺失，发现是环境问题，将Node版本改为15.x后解决。 博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议 本文永久链接是：https://goopher.tk/posts/64028.html","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"用git提交新项目到github","slug":"github/用git提交新项目到github","date":"2022-08-11T03:56:55.000Z","updated":"2022-08-11T03:56:55.000Z","comments":true,"path":"2022/08/11/github/用git提交新项目到github/","link":"","permalink":"http://example.com/2022/08/11/github/%E7%94%A8git%E6%8F%90%E4%BA%A4%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%88%B0github/","excerpt":"","text":"1、（先进入项目文件夹）通过命令 git init 把这个目录变成 git 可以管理的仓库1git init 2、把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件1git add . 3、用命令 git commit 告诉 Git，把文件提交到仓库。引号内为提交说明1git commit -m &#x27;first commit&#x27; 4、关联到远程库123git remote add origin` 你的远程库地址如：git remote add origin https://github.com/githubusername/demo.git` 5、获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败）1git pull --rebase origin master 6、把本地库的内容推送到远程，使用 git push 命令，实际上是把当前分支 master 推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。1git push -u origin master 7、状态查询命令1git status","categories":[{"name":"github","slug":"github","permalink":"http://example.com/categories/github/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}],"author":"作者"},{"title":"正确运行vue打包后的项目","slug":"正确运行vue打包后的项目","date":"2022-08-08T14:54:51.000Z","updated":"2022-08-08T14:54:51.000Z","comments":true,"path":"2022/08/08/正确运行vue打包后的项目/","link":"","permalink":"http://example.com/2022/08/08/%E6%AD%A3%E7%A1%AE%E8%BF%90%E8%A1%8Cvue%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"这篇文章给大家分享的是有关怎么使用 webpack 打包后的 vue 项目正确运行的内容。小编觉得挺实用的，因此分享给大家做个参考，一起跟随小编过来看看吧。 我们知道使用 webpack 打包 vue 项目后会生成一个 dist 文件夹，dist 文件夹下有 html 文件和其他 css、js 以及图片等，那么打包后的文件该如何正确运行呢？ 倘若直接打开 html 文件，会报如下错误： 那么该如何运行呢？其实可以将生成的 dist 文件部署到 express服务器上运行。 （1）、安装 express-generator 生成器。1npm install express-generator -g // 也可使用cnpm比较快 （2）、创建一个 express 项目。1express expressName // expressName是项目名 （3）、进入项目目录，安装相关项目依赖。12cd expressNamenpm install // 或cnpm install （4）、此时生成的项目目录应该是这样的： （5）、将 dist 文件夹下的所有文件复制到 express 项目的 publick 文件夹下面，然后运行 npm start 来启动 express 项目。（6）、打开浏览器，输入 localhost:3000 就可以看到效果了。例如我的是这样的：感谢各位的阅读！关于“怎么使用 webpack 打包后的 vue 项目正确运行”这篇文章就分享到这里了，希望以上内容可以对大家有一定的帮助，让大家可以学到更多知识，如果觉得文章不错，可以把它分享出去让更多的人看到吧！","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}],"author":"作者"},{"title":"phpMyAdmin最新下载安装教程","slug":"tutorial/phpMyAdmin最新下载安装教程","date":"2022-08-08T14:26:31.000Z","updated":"2022-08-08T14:26:31.000Z","comments":true,"path":"2022/08/08/tutorial/phpMyAdmin最新下载安装教程/","link":"","permalink":"http://example.com/2022/08/08/tutorial/phpMyAdmin%E6%9C%80%E6%96%B0%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"","text":"本篇文章主要为大家详细地介绍了PHPmyadmin 安装教程。 PHPmyadmin 是我们在日常项目开发中常用的 MySQL 数据库管理器之一！那么如何快速下载安装好 PHPmyadmin 就是新手朋友们不可或缺的一项技能了，掌握了这个技能后无论你是需要重新搭建开发环境还是后期误删 PHPmyadmin，这些问题都能轻松解决。 下面我们结合具体的图文信息为大家详细地介绍如何下载安装 PHPmyadmin以及PHPmyadmin 怎么登陆启动的方法！ 一、下载 PHPmyadmin打开 PHP 中文网中的 PHPmyadmin 工具下载链接：http://www.php.cn/xiazai/gongju/97， 点击本地下载，即可下载 PHPmyadmin 压缩包。 二、更改文件夹名及部分代码当我们下载了 PHPmyadmin 文件的压缩包后，将其解压到 c 盘的根目录下。并且把原先的文件夹名称改为 PHPmyadmin。 然后打开这个文件夹，找到 config.sample.inc.php，将其重命名为 config.inc.php。 最后打开 config.inc.php 文件，找到这段代码： 1$cfg[&#x27;blowfish_secret&#x27;] = &#x27;&#x27; 将其改为下面这么这段代码： 1$cfg[&#x27;blowfish_secret&#x27;] = &#x27;c4ca4238a0b923820dcc509a6f75849b&#x27;;//一个长字符串密码就行 保存退出即可。 三、新建一个 phpmyadmin.conf 文件首先我们要找到 PHP 环境中的 Apache 的 conf 文件夹，在里面直接新建一个 phpmyadmin.conf 文件。例如在 PHPstudy 环境下，conf 文件夹所在位置如下图： 然后在这个新建的文件里，直接复制粘贴这段代码： 12345678910Alias /phpmyadmin &quot;c:/phpMyAdmin/&quot;&lt;Directory &quot;c:/phpMyAdmin/&quot;&gt;Options Indexes FollowSymLinks MultiViewsAllowOverride allRequire all grantedphp_admin_value upload_max_filesize 128Mphp_admin_value post_max_size 128Mphp_admin_value max_execution_time 360php_admin_value max_input_time 360&lt;/Directory&gt; 最后保存退出即可。 四、修改配置文件 httpd.conf在 Apache 的 conf 文件夹里找到 httpd.conf 文件，打开文件，在文本末尾处加上这一段代码： 1Include conf/phpmyadmin.conf 最后重启 Apache 即可。 五、登录启动 PHPmyadmin经过上述四步后，就已经成功安装好了 PHPmyadmin，那怎样登录 PHPmyadmin？此时就可以访问这个链接地址：localhost&#x2F;phpmyadmin，或者 127.0.0.1&#x2F;phpmuadmin。注：链接里的 phpmyadmin 需小写。 出现了 PHPmyadmin 登录界面： 一般初始的用户名密码都是 root，点击执行即可成功登陆启动 PHPmyadmin 的管理界面，如下图： 那么以上文章就是关于 PHPmyadmin 下载安装的具体过程介绍，希望对有需要的朋友有所帮助！ 各位也可以参考对应的视频教程【下载安装以及配置线上数据库管理工具 PHPMyAdmin】，此视频解说更加直观、浅显易懂！ 文章来源于：https://www.php.cn/jishu/mysql/409664.html","categories":[{"name":"破解软件","slug":"破解软件","permalink":"http://example.com/categories/%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"phpMyAdmin","slug":"phpMyAdmin","permalink":"http://example.com/tags/phpMyAdmin/"}],"author":"作者"},{"title":"WebStorm破解教程","slug":"tutorial/WebStorm破解教程","date":"2022-08-08T13:40:59.000Z","updated":"2022-08-08T13:40:59.000Z","comments":true,"path":"2022/08/08/tutorial/WebStorm破解教程/","link":"","permalink":"http://example.com/2022/08/08/tutorial/WebStorm%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/","excerpt":"","text":"最新 2021.3 版本 WebStorm 破解教程，WebStorm 破解补丁 ja-netfilter，永久激活 5000 年网上有一位不知名的的大佬在 zhile 大佬的开源文件的基础上，进行了升级！ 针对最新 2021.3 版本可以做到永久激活、直接激活 5000 年！ 说明 本教程适用于 JetBrains 全系列产品：IntelliJ IDEA、APPCode、CLion、DataGrip、GoLand、PhpStorm、PyCharm、Rider、RubyMine 和 WebStorm 包括 Code With Me； 本教程适用于 Windows&#x2F;Mac&#x2F;Linux 系统； 本教程所使用的 jar 是开源的，所以非常安全，大家无需担心安全问题； 教程演示卸载旧版本 WebStorm首先将电脑上的旧版本 WebStorm 卸载干净，如果你的电脑是一台新电脑、没有安装过 WebStorm ，那么你就可以跳过这一步。 一定要按照下图所示勾选，确保完全卸载干净。 然后我们再从 WebStorm 官网下载最新版本的 WebStorm，点击跳转官网下载 双击运行 WebStorm 安装包，默认安装位置是C:\\Program Files\\JetBrains\\WebStorm 2021.3 ，我是安装在默认位置。 大家要记住 WebStorm 的安装位置，等一下会用到！ 然后一直点击 Next，再点击 Install 开始安装。 安装完成之后，如下图所示不要勾选 ，我们直接点击下面的 Finish 结束。 激活步骤 首先获取激活补丁 下载链接：https://docs.qq.com/doc/DY015WHZvd1BPa1hK 下载的激活补丁解压之后，直接放到电脑 D 盘下面，当然放在其他盘也是可以的。 切记！解压之后直接放 D 盘，不要删除任何文件！ 切记！解压之后直接放 D 盘，不要删除任何文件！ 切记！解压之后直接放 D 盘，不要删除任何文件！ 我是放在 D 盘下面，所以激活补丁路径为： 1-javaagent:d:/zhile_agent_po/ja-netfilter.jar 然后按照最开始 WebStorm 的安装路径，找到 WebStorm 的根目录，再打开 bin 文件夹。 找到 webstorm64.exe.vmoptions 文件并且打开。 将激活补丁的路径粘贴进去并且保存。 1-javaagent:d:/zhile_agent_po/ja-netfilter.jar 现在我们打开 WebStorm 软件，如下图所示点击 OK。 复制补丁文件里面的激活码 回到 WebStorm ，点击 Activation code，将激活码粘贴进去，然后点击 Activate 激活。 如下如所示，就说明你已经激活成功了。 切记，后续不要升级 WebStorm，否则激活可能会失效！！！ 作者：IDEA 精选教程 https://www.bilibili.com/read/cv14405690 出处：bilibili","categories":[{"name":"破解软件","slug":"破解软件","permalink":"http://example.com/categories/%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"WebStorm","slug":"WebStorm","permalink":"http://example.com/tags/WebStorm/"}],"author":"作者"},{"title":"大合集","slug":"大合集","date":"2022-08-08T07:21:34.000Z","updated":"2022-08-08T07:21:34.000Z","comments":true,"path":"2022/08/08/大合集/","link":"","permalink":"http://example.com/2022/08/08/%E5%A4%A7%E5%90%88%E9%9B%86/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;style&gt; .links-content&#123; margin-top:1rem; &#125; .link-navigation::after &#123; content: &quot; &quot;; display: block; clear: both; &#125; .card &#123; width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; &#125; .card:nth-child(odd) &#123; float: left; &#125; .card:nth-child(even) &#123; float: right; &#125; .card:hover &#123; transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); &#125; .card a &#123; border:none; &#125; .card .ava &#123; width: 100px!important; height: 100px!important; margin:0!important; margin-right: 100px!important; border-radius:4px; &#125; .card .card-header &#123; font-style: italic; overflow: hidden; width: 100%; &#125; .card .card-header a &#123; font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; &#125; .card .card-header a:hover &#123; color: #d480aa; text-decoration: none; &#125; .card .card-header .info &#123; font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; &#125;&lt;/style&gt; 鸠摩搜索 鸠摩搜索 多种内容大收集书籍下载 网站：鸠摩搜索 网站简介： 书籍查询，下载 推荐指数： 💛💛💛 网址：https://www.jiumodiary.com/ 爱问共享资料 网站简介： 书籍查询，下载 网址：https://ishare.iask.sina.com.cn/ 去中心化免费电子书共享社区 网站简介： 网址：https://ebook2.lorefree.com/ 苦瓜书盘 网站简介： 网址：http://www.kgbook.com/ 网址：https://sobooks.cc/ 古腾堡计划 网站简介：免费电子书的图书馆 网址：https://www.gutenberg.org/ 书屋集合 网址：https://www.ctakj.com/11684.htm 个性网站 有格调 网址：https://www.ugediao.com/ 成都世界大学生运动赛 网址：https://www.2021chengdu.com/ 天天看新片 推荐指数：❤❤❤❤❤ 网址：https://cn1.ae101.guru/ 文件蜈蚣 网站简介：文件蜈蚣是一个全能网络文件上传&#x2F;下载器 网址：http://filecxx.com/zh_CN/index.html 图片网站 爱美女 网址：https://www.2meinv.com/ 收集壁纸专家 推荐指数：❤❤❤ 网址：https://www.3gbizhi.com/ 图虫题材 网站：https://tuchong.com/explore/ 在线电脑壁纸 网址： https://tool.liumingye.cn/wallpaper/ 唯一图库 网址： https://www.mmonly.cc/ 极简壁纸 网址： https://bz.zzzmh.cn/index 个人网址 知乎： 网址：https://www.zhihu.com/people/mo-shang-hua-kai-46-1-55 notion 推荐指数：❤❤❤❤❤ 网址：https://www.notion.so/Getting-Started-ff7285a86ec0466b83dd5f98657ea25c 模板网址：https://www.notion.so/Notion-Template-Gallery-181e961aeb5c4ee6915307c0dfd5156d 网站接口文档 网址：https://www.showdoc.com.cn/item/index 我的window账户 网址：https://account.microsoft.com/profile/?refd=login.microsoftonline.com 有趣应用 书籍封面设计 网址： https://www.canva.cn/templates/search/5Lmm57GN5bCB6Z2iX64/ 临时邮箱——黑海洋 - WIKI 网址：https://blog.upx8.com/2379 临时邮箱 介绍：十分钟邮箱 推荐指数： ❤❤❤❤❤ 网址：https://linshiyou.com/#/bagduz@youxiang.dev 音乐素材 网址1： https://www.tuke88.com/peiyue/?se=1&amp;pl=138-1713&amp;ky=300305&amp;bd_vid=10769662979871082100 网址2： https://www.51miz.com/shipin/0-3-0-1.html?utm_term=3883645&amp;utm_source=baidu&amp;bd_vid=7734437017442267000 网址3： https://www.51miz.com/ 色彩网址——颜色 推荐指数： ❤❤❤❤❤❤ 网址1： https://webgradients.com/ 编程相关 编程学习： 网站简介：html、js、ES6等等 推荐指数：❤❤❤ 网址：https://wangdoc.com/ 网站编程集合 网址： https://www.5cv.top/ 编程自学之路 网址： https://www.r2coding.com/#/ web全栈体系 网站简介： 全面的编程知识 网址： https://hejialianghe.gitee.io/ IconPark资源站 https://iconpark.oceanengine.com/home git 开源软件和项目工具插件 在线PS 网址1： https://ps.gaoding.com/#/ 网址2： https://www.photopea.com/ Listen 1 音乐播放器 网址： https://listen1.github.io/listen1/ 磁力工具 老王磁力 网址： https://laowangfo.xyz/ 磁力狐 推荐指数：❤❤❤❤❤ 网址： https://sk.btfox.pw/ 柠檬磁力 网址： https://lemonso.xyz/ 海盗湾 网站简介：下载音乐、电影、游戏、软件 网址：https://pirate-proxy.page/ 磁力猩球—— 网址：https://cili-xingqiu.co 集成网站 专注修车工具30年 网址：https://pornbt.net/ 网址：http://www.91bt.xyz/ 欣赏小姐姐-短视频 网址：https://xjiejie.co/ 暂时无法访问 网址：http://www.91bt.xyz/ 夏末浅笑 网站简介：个人博客，涵盖诸多感兴趣的内容 网址：https://blog.ccswust.org/ 刘涛的个人博客 网站简介：个人博客，涵盖了前端相关知识笔记和实用工具 网址： http://www.spicyboy.cn/ 小豆同学 网站简介：一个喜欢计算机和美术的小朋友的博客网站 网址：https://douzaixue.github.io/ 流萤书签——个人书签导航 网站简介：个人书签合集 网址：http://warbler.duwanyu.com/ 刘志进实验室 网站简介：个人开发网站，音乐搜索和解析，各种小工具和小游戏 推荐指数：❤❤❤ 网址：https://music.liuzhijin.cn/ 小众软件 网址：https://www.appinn.com/ 导航 网址：http://nav.momen.vip/ 简法主页——自定义浏览器主页 网址：https://www.jianfast.com/?time=ks1cu1x gogoing 网址：https://gogoing.work/ 字体识别与搜索 网址：https://so.17font.com/ 书法字体在线转换器 网址：http://m.diyiziti.com/ 个人开发工具 推荐指数： ❤❤❤❤ 网址： https://tool.liumingye.cn/ 个人开发组件库 网址： http://jyeontu.xyz/jvuewheel/#/homePage 网易云音乐API 简介：网易云音乐 NodeJS 版 API，具备多达200多个接口 网站：https://douzaixue.github.io/ 电脑系统 macOS系统下载 https://www.apple114.com/pages/macos/ 苹果系统 网址：https://www.apple114.com/ 黑苹果——资源 网址：https://imacosx.com/ 苹果电脑安装双系统教程 [(http://www.runker.net/tag/苹果电脑安装双系统教程) 虚拟机安装黑苹果教程 网址： https://www.w3h5.com/post/236.html window系统下载仓储站——纯净系统 推荐指数： ❤❤❤❤❤ 网址：https://hellowindows.cn/ windows10 + 优麒麟双系统安装 简介：安装教程 网址：https://mp.weixin.qq.com/s/h7Lcyb5-PqB0q-pHUINCug 影视影院 创世影院 网址：http://www.cuangs.com/ 片库 网址：https://www.pkmp4.com/","categories":[{"name":"合集","slug":"合集","permalink":"http://example.com/categories/%E5%90%88%E9%9B%86/"}],"tags":[{"name":"合集","slug":"合集","permalink":"http://example.com/tags/%E5%90%88%E9%9B%86/"}],"author":"作者"},{"title":"HelloWindows","slug":"HelloWindows","date":"2022-08-08T06:40:33.000Z","updated":"2022-08-08T06:40:33.000Z","comments":true,"path":"2022/08/08/HelloWindows/","link":"","permalink":"http://example.com/2022/08/08/HelloWindows/","excerpt":"","text":"HelloWindows，是一个由国人搭建，提供系统镜像下载地址、下载方法和激活方法的系统资源网站。除了系统镜像外，也提供Office&#x2F;WPS的特殊版本。网站代码部署在开源网站GitHub上。系统下载地址以磁链为主，工具分享以蓝奏云为主。 网站地址： https://hellowindows.cn","categories":[{"name":"HelloWindows","slug":"HelloWindows","permalink":"http://example.com/categories/HelloWindows/"}],"tags":[{"name":"HelloWindows","slug":"HelloWindows","permalink":"http://example.com/tags/HelloWindows/"}],"author":"作者"},{"title":"Navicat 15 for MySQL 安装注册激活","slug":"tutorial/Navicat 15 for MySQL的安装注册激活","date":"2022-08-04T08:17:33.000Z","updated":"2022-08-04T08:17:33.000Z","comments":true,"path":"2022/08/04/tutorial/Navicat 15 for MySQL的安装注册激活/","link":"","permalink":"http://example.com/2022/08/04/tutorial/Navicat%2015%20for%20MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E6%B3%A8%E5%86%8C%E6%BF%80%E6%B4%BB/","excerpt":"","text":"Navicat 15 for MySQL 安装注册激活Navicat 15 for MySQL 安装 下载链接：https://pan.baidu.com/s/1ckdYJvWbsDXMpOpiie0_ug提取码：wzx1 百度网盘下载到指定的文件夹，将下载好的文件解压到当前文件夹 安装 Navicat 15 for MySql1.双击安装程序 2.下一步 3.勾选我同意，下一步 4.点击浏览，指定安装路径，也可以默认 5.下一步 6.下一步 7.安装 8.等待安装，安装好了，点击完成，这样就已经安装好 Navicat 15 for MySQLNavicat 15 for MySQL 激活1.将下面文件复制到安装的路径下 复制路径，一定要复制到安装的路径，不然在解压的文件里直接激活会报错 2.以管理员身份运行 3.按照下面内容选择 4.点击右上角 Patch 5.点击确认 6.点击 Gengerate 7.点击 Copy 8.点击桌面 Navicat 15 for MySQL 9.点击注册 10.ctrl+v 把注册码粘贴到这里，点激活 11.需要手动激活 12.复制以下请求码 13.粘贴到破解程序的 Request Code ，然后点击 Generate 14.破解程序会自动把激活码填充上，然后点击 激活，再点击确认 这个时候已经成功破解了","categories":[{"name":"破解软件","slug":"破解软件","permalink":"http://example.com/categories/%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}],"author":"作者"},{"title":"Electron的安装与使用","slug":"electron/Electron的安装与使用","date":"2022-08-03T16:46:00.000Z","updated":"2022-08-03T16:46:00.000Z","comments":true,"path":"2022/08/04/electron/Electron的安装与使用/","link":"","permalink":"http://example.com/2022/08/04/electron/Electron%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Electron 是使用 JavaScript, HTML 和 CSS 构建跨平台的桌面应用本文基于 Windows 进行开发的过程，记录下来，以便日后使用，Electron 官网：https://electronjs.org/docs 1、安装 node.js进入官网下载、安装。https://nodejs.org/en/ 2、安装 cnpm安装命令： npm install -g cnpm --registry=https://registry.npm.taobao.org 3、安装 Electron安装命令：cnpm install -g electron 4、安装 Electron-forgeElectron工具整合项目：https://github.com/electron-userland/electron-forge 安装命令： cnpm install -g electron-forge 5、新建项目F 盘新建Electron项目文件夹 F:Electron。 在Electron文件夹下打开命令窗口来启动cmd.exe。 执行electron-forge init &lt;项目名称&gt;命令来生成名为 myapp 的项目文件夹，同时安装项目所需要的模块、依赖项等。 安装命令： electron-forge init myapp 6、启动项目cd 到myapp目录下，执行命令electron-forge start来启动 app（也可以简单的用npm start来运行）。 7、项目文件项目的目录结构： node_modules：文件夹下是各种模块、类库， src：app 的源代码文件， package.json：是描述包的文件。 src&#x2F;index.js：这是 app 主进程的入口，在这里创建了 mainWindow 浏览器窗口，使用 mainWindow.loadURL(file:&#x2F;&#x2F;${__dirname}&#x2F;index.html&#96;)来加载 index.html 主页， 我们也可以在此链接我们需要链接的网址，来实现 web 桌面应用，例：mainWindow.loadURL(https://www.cnblogs.com/)，使用 mainWindow.webContents.openDevTools()&#96;来打开开发者工具用于调试（这个操作通常在发布 app 时删除）。 然后是 app 的事件处理： ready：当Electron完成初始化后触发，这里初始化后就会去创建浏览器窗口并加载主页面。 window-all-closed：当所有浏览器窗口被关闭后触发，一般此时就退出应用了。 activate：当 app 激活时触发，一般针对 macOS 要需要处理。 src&#x2F;index.html：这是主页面，除了显示 Well hey there!!!的信息外，没什么具体内容。 8、package.json 配置 “productName”:”myapp” myapp 是打包后的文件名称 “version”:”1.0.0” 版本号 若想更换打包程序的图标，可以在 config-&gt;electronPackagerConfig-&gt;icon 中进行设置， (例如：我们把 app.ico 放在 src 目录下就可以这样配置”icon”:”src&#x2F;favicon.ico”） 9、编译打包输入以下命令进行编译打包： npm run make 修改package.json，在electronPackagerConfig部分添加&quot;asar&quot;: true。 123&quot;electronPackagerConfig&quot;: &#123; &quot;asar&quot;: true&#125; 重新打包后源码文件会被打包进app.asar文件中（该文件仍然在 src 目录下）。 可以直接运行打包后的myapp.exe启动程序","categories":[{"name":"Electron","slug":"Electron","permalink":"http://example.com/categories/Electron/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"http://example.com/tags/Electron/"}]},{"title":"PicGo+typora上传图片失败报422的原因及解决方法","slug":"picgo/PicGo+typora上传图片失败报422的原因及解决方法","date":"2022-08-03T09:31:35.000Z","updated":"2022-08-03T09:31:35.000Z","comments":true,"path":"2022/08/03/picgo/PicGo+typora上传图片失败报422的原因及解决方法/","link":"","permalink":"http://example.com/2022/08/03/picgo/PicGo+typora%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5%E6%8A%A5422%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"picgo 用 github 作图床，使用 typora 上传图，出现 StatusCodeError: 422 的原因及解决方法 我在使用过程中 PicGo 出现了 StatusCodeError: 422 的错误，上传图片失败。通过百度得知是以下原因造成的 PicGo 目前不支持在 gitbub 上上传同名文件，上传同名文件就会报错，即使是两张不同的图片。 解决方式也很简单，Picgo 开启上传时重命名和时间戳重命名就可以结局，或者把 github 里面已经有的同名文件删除，都可以解决这个问题。","categories":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/categories/PicGo/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"}]},{"title":"hexo之评论系统——twikoo","slug":"hexo/hexo之评论系统——twiko","date":"2022-08-02T05:07:14.000Z","updated":"2022-08-02T05:07:14.000Z","comments":true,"path":"2022/08/02/hexo/hexo之评论系统——twiko/","link":"","permalink":"http://example.com/2022/08/02/hexo/hexo%E4%B9%8B%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94twiko/","excerpt":"","text":"写在前面Hexo 博客里面支持的评论系统有：Disqus、Disqusjs、Livere、Gitalk、Valine、Waline、Utterances、Facebook Comments、Twikoo、Giscus，这里面有的评论有的是国外的服务器、有的有广告，本文要讲的 Twikoo 是在 butterfly3.3 之后支持的，它支持邮件提醒、微信提醒等功能，还是非常好用的。 注意：本文仅针对腾讯云的部署方式中的「手动部署」，其他详细部署方式请参考官方文档。 购买云开发套餐温馨提示：如果你已经拥有云开发环境，可以忽略这一步，直接到【登录授权】。1、进入云开发 CloudBase，进行登录、实名认证操作，点击控制台： 2、点击云产品，选择云开发 CloudBase： 3、点击新建，选择空模板，点击下一步： 4、选择合适的套餐进行购买： 温馨提示：地域选择【上海】计费方式选择【包年包月】环境名称自由填写套餐版本选择【特惠基础版 1】,白嫖我选择免费版 5、按照上面的步骤操作之后，我们会拥有一个云开发环境： 注意：记录一下这个环境 ID，我们后面会用。 登录授权环境 - 登录授权 - 开启【匿名登录】 安全配置环境 - 安全配置 - 添加域名：将自己的域名添加进去 温馨提示：如果更改了域名发现评论加载不出来的情况，请记得回来更改为最新域名，尤其是那些刚开始使用 github.io 来作为自己博客域名的童鞋，哪天购买了自己的域名，记得换，记得换，记得换（重要的事情说三遍)。 云函数1、环境 - 云函数 - 新建云函数 温馨提示：函数名称填写：twikoo创建方式选择：空白函数运行环境选择：Nodejs10.15函数内存选择：128M必须按照上面的方式选择，不要瞎选瞎写好吧。 2、清空上图中「函数代码」框里的内容，复制exports.main = require(&#39;twikoo-func&#39;).main到里面，点击确定，如下：3、点击「twikoo」函数名进入云函数详情页 - 函数代码 - 文件 - 新建文件，输入 package.json 确定，将&#123; &quot;dependencies&quot;: &#123; &quot;twikoo-func&quot;: &quot;1.5.11&quot; &#125; &#125;内容复制到新建的文件package.json里面。 配置 butterfly 主题文件打开主题Volantis下的配置文件 123456789101112131415comments: title: &lt;i class=&#x27;fa-solid fa-comments&#x27;&gt;&lt;/i&gt; 评论 subtitle: service: twikoo #giscus # 可选评论系统 # twikoo giscus(实现了，只是嫌弃样式丑陋用了第一个) # Twikoo 有限使用这个，这个好看呀 # https://twikoo.js.org/ twikoo: js: https://unpkg.com/twikoo@latest # 建议锁定版本 path: window.location.pathname # 全局评论地址 # 其他配置项按照yml格式继续填写即可 除了 [el path] 选项 envId: vanilla-yiyi-6gxfhkqy46f064ce # 腾讯云环境id 这里我做了改写，这个是不真实的 placeholder: #全局评论占位，也可以在管理面板中的配置管理处设置（此处优先级更高） 显示效果如下： 最后关于 Twikoo 评论系统详细文档请参考：Twikoo 官方文档（https://twikoo.js.org）文章来源于网络： 作者：重庆妹子在霾都链接：https://www.jianshu.com/p/c00b8e329f46来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"Hexo系列","slug":"Hexo系列","permalink":"http://example.com/categories/Hexo%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"评论系统","slug":"评论系统","permalink":"http://example.com/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"name":"twikoo","slug":"twikoo","permalink":"http://example.com/tags/twikoo/"}],"author":"作者"},{"title":"hexo之站点统计——busuanzi","slug":"hexo/hexo之站点统计——busuanzi","date":"2022-08-01T14:32:56.000Z","updated":"2022-08-01T14:32:56.000Z","comments":true,"path":"2022/08/01/hexo/hexo之站点统计——busuanzi/","link":"","permalink":"http://example.com/2022/08/01/hexo/hexo%E4%B9%8B%E7%AB%99%E7%82%B9%E7%BB%9F%E8%AE%A1%E2%80%94%E2%80%94busuanzi/","excerpt":"","text":"本片介绍的是站点信息统计之 busuanzi 一、站点信息1.1 在_config.volantis.yml 搜索统计,显示有站点统计信息123456789visitcounter: # 站点统计访客开启入口在下面⬇ siteuv: enable: true text: &#x27;本站访客数：&#x27; unit: &#x27;人&#x27; sitepv: enable: true text: &#x27;本站总访问量：&#x27; unit: &#x27;次&#x27; 1.2 接下来就是 analytics 引入 busuanzi,这里就需要配置个人的 app_id 和 app_key1234567# 站点统计访客开启入口，引入busuanzi，并配置属于自己的app_id和app_keyanalytics: busuanzi: volantis-static/libs/busuanzi/js/busuanzi.pure.mini.js leancloud: # 请使用自己的 id &amp; key 以防止数据丢失 app_id: u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI app_key: jfHtEKVE24j0IVCGHbvuFClp custom_api_server: # 国际版一般不需要写，除非自定义了 API Server 二、获取 busuanzi 的配置信息2.1 打开 leancloud 官网，注册账号，该认证认证 leancloud 官网:https://www.leancloud.cn/ ,点击免费使用，注册账号 2.2 登录账号注册应用 2.3 点击应用，选择应用 2.4 点击设置，应用凭证，右侧就是我们想要的配置信息了 复制保存我们的配置信息，填入指定位置，页面就是有相关信息展示了 效果展示 tip: 本地运行显示数据有点夸张了，还有点延迟，但是部署之后会显示正常数据","categories":[{"name":"Hexo系列","slug":"Hexo系列","permalink":"http://example.com/categories/Hexo%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"busuanzi","slug":"busuanzi","permalink":"http://example.com/tags/busuanzi/"},{"name":"站点统计","slug":"站点统计","permalink":"http://example.com/tags/%E7%AB%99%E7%82%B9%E7%BB%9F%E8%AE%A1/"}],"author":"作者"},{"title":"hexo之评论系统——giscus","slug":"hexo/hexo之评论系统——giscus","date":"2022-07-30T17:08:28.000Z","updated":"2024-09-04T08:33:54.232Z","comments":true,"path":"2022/07/31/hexo/hexo之评论系统——giscus/","link":"","permalink":"http://example.com/2022/07/31/hexo/hexo%E4%B9%8B%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94giscus/","excerpt":"","text":"本篇主要讲的是 hexo 主题 volantis 的评论系统相关的 giscus 一、评论系统的选择 giscus1.1 打开文件_config.volantis.yml，搜索 comments 评论部分，可以看到这里选择的是 giscus12345comments: title: &lt;i class=&#x27;fa-solid fa-comments&#x27;&gt;&lt;/i&gt; 评论 subtitle: service: giscus # 可选评论系统 # 1.2 继续搜索 giscus，显示需要配置一些 repo&#x2F;repo-id 等参数1234567891011121314151617# giscus# https://giscus.app# https://github.com/laymonage/giscusgiscus: # 以下配置按照 yml 格式增删填写即可 repo: txw1314/comment-giscus repo-id: R_kgDOHvE8vw category: Comments category-id: DIC_kwDOHvE8v84CQgFl mapping: &quot;title&quot; reactions-enabled: &quot;1&quot; emit-metadata: &quot;0&quot; position: &quot;top&quot; loading: &quot;lazy&quot; crossorigin: &quot;anonymous&quot; lang: &quot;zh-CN&quot; # 以上配置按照 yml 格式增删填写即可 二、如何获取 giscus 的相关配置2.1 在 github 的操作2.1.1 新建一个关于评论的仓库我这里命名的是 comment-giscus,点击 Setting 2.1.2 继续往下滚动到 Features，勾选 Wikis 2.1.3 继续滚动，勾选 Discussions。 2.2 在 GitHub 代码库上的讨论页面创建一个类别 比如 “Comments（评论）”——或者选择现有的类别。 2.2.1 如果没有，那就新建类别 2.2.2 填写 title 和详情，点击 create 创建完成 2.2.3 创建完成，分类里面有了我们新增的分类 2.3 转到 https://github.com/apps/giscus，按照提示操作，并仅授予对选定代码库的访问权限。2.3.1 安装 giscus 在根目录安装 giscus : npm install giscus 2.3.2 选择建立的评论仓库 2.3.3 确认账号密码 2.3.4 选择完成 2.4 在 giscus 的操作，我们需要配置 giscus 的小部件。 打开网页：giscus 2.4.1 选择语言和仓库，输入之前 github 创建仓库名称，如用username/reponame，这里包括用户名和仓库名称， 注意&#x2F;前后不能有空格，不能输错，否则下面会提示报错 2.4.2 页面映射关系，这里我选择的是第三个 2.4.3 然后选择 Discussion 分类和特性分类选择我们上面新建的分类，特性我选择了箭头不两个，也可不选，主题随便选一个就行，不选也没关系这个不影响 2.4.4 启用 giscus一切就绪之后，Giscus 将根据你的设置生成一个脚本标签，这就是我们想要的 giscus 的配置信息了。你可以将其粘贴到你的代码中，记得把这个保存下来，不然还要在操作一下这步骤重新生成了 这是最终结果","categories":[{"name":"Hexo系列","slug":"Hexo系列","permalink":"http://example.com/categories/Hexo%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"评论系统","slug":"评论系统","permalink":"http://example.com/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"name":"giscus","slug":"giscus","permalink":"http://example.com/tags/giscus/"}]},{"title":"typora破解版安装","slug":"tutorial/typora破解版安装","date":"2022-07-30T15:56:45.000Z","updated":"2024-09-04T08:33:54.235Z","comments":true,"path":"2022/07/30/tutorial/typora破解版安装/","link":"","permalink":"http://example.com/2022/07/30/tutorial/typora%E7%A0%B4%E8%A7%A3%E7%89%88%E5%AE%89%E8%A3%85/","excerpt":"","text":"typora 收费，对程序猿来说是不可能的，我只会白嫖，今天在小破站看到一个破解版的 typora 的安装，分享给大家。 我把软件和破解文件放到了自己的阿里云盘分享给大家，附上链接：「typora1.3.8」等文件 https://www.aliyundrive.com/s/WLHNPidNYrL 1.1 下载完之后，选择安装包正常安装即可 1.2 打开破解插件，复制文件。桌面 typora 图标右键打开文件所在位置，粘贴复制的破解文件，替换即可，此时已经破解完成了打开 typora，点击帮助—我的许可证，将看到破解好的 typora，是不是特别简单，我也是惊艳到了。","categories":[{"name":"破解软件","slug":"破解软件","permalink":"http://example.com/categories/%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"typora","slug":"typora","permalink":"http://example.com/tags/typora/"}]},{"title":"PicGo相册不能显示问题及解决办法","slug":"picgo/PicGo相册不能显示问题及解决办法","date":"2022-07-30T14:30:02.000Z","updated":"2024-09-04T08:33:54.233Z","comments":true,"path":"2022/07/30/picgo/PicGo相册不能显示问题及解决办法/","link":"","permalink":"http://example.com/2022/07/30/picgo/PicGo%E7%9B%B8%E5%86%8C%E4%B8%8D%E8%83%BD%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"我的PicGo图片上传成功了，但是相册区域图片不能正常显示，如下图所示 解决办法1.0 重启应用退出应用，重新启动，上传的图片能正常显示 2.0 卸载应用，重新安装卸载重装 PicGo，不需要重新配置，之后上传的图片都能正常显示 3.0 打开picgo设置，找到设置Server，把端口号修改成36677 4.0 修改host文件 原因是github屏蔽掉了图片，结局办法就是修改host，我就是用的这个方法解决的 host路径： 1C:\\Windows\\System32\\drivers\\etc\\hosts 找到host文件，用记事本格式打开，添加代码 GitHub Start1234567891011121314151617181920212223242526140.82.113.3 github.com140.82.114.20 gist.github.com151.101.184.133 assets-cdn.github.com151.101.184.133 raw.githubusercontent.com151.101.184.133 gist.githubusercontent.com151.101.184.133 cloud.githubusercontent.com151.101.184.133 camo.githubusercontent.com151.101.184.133 avatars0.githubusercontent.com199.232.68.133 avatars0.githubusercontent.com199.232.28.133 avatars1.githubusercontent.com151.101.184.133 avatars1.githubusercontent.com151.101.184.133 avatars2.githubusercontent.com199.232.28.133 avatars2.githubusercontent.com151.101.184.133 avatars3.githubusercontent.com199.232.68.133 avatars3.githubusercontent.com151.101.184.133 avatars4.githubusercontent.com199.232.68.133 avatars4.githubusercontent.com151.101.184.133 avatars5.githubusercontent.com199.232.68.133 avatars5.githubusercontent.com151.101.184.133 avatars6.githubusercontent.com199.232.68.133 avatars6.githubusercontent.com151.101.184.133 avatars7.githubusercontent.com199.232.68.133 avatars7.githubusercontent.com151.101.184.133 avatars8.githubusercontent.com199.232.68.133 avatars8.githubusercontent.com# GitHub End tip: host文件修改需要管理员权限，可在桌面复制一份，用修改完的文件替换掉原来的文件即可，权限可以自己更改，搞完再改回去","categories":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/categories/PicGo/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"}]},{"title":"github克隆项目失败","slug":"github/github克隆项目失败","date":"2022-07-29T11:00:25.000Z","updated":"2024-09-03T07:42:24.933Z","comments":true,"path":"2022/07/29/github/github克隆项目失败/","link":"","permalink":"http://example.com/2022/07/29/github/github%E5%85%8B%E9%9A%86%E9%A1%B9%E7%9B%AE%E5%A4%B1%E8%B4%A5/","excerpt":"","text":"unable to access ‘https://github.com/用户名/仓库名.git/&#39;: SSL certificate problem: self问题解决前言 今天想在github上找个项目玩玩，但是发现clone不下来，百度没有找到解决方案，于是又把git重装了一遍，发现还是不能clone,而且不能push，而且是同样的错误。于是Google了一下找到解决方案 原因Git client in Fisheye&#x2F;Crucible server perform verification on the SSL certificate and stop the process if it is unknown. 大概意思是：Fisheye&#x2F;Crucible服务器不能识别git的SSL证书，所以操作停止执行。 解决 在git命令行输入以下命令即可 1git config --global http.sslVerify false","categories":[{"name":"github","slug":"github","permalink":"http://example.com/categories/github/"}],"tags":[{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"}]},{"title":"使用github建立图床,picgo和typora上传图片","slug":"github/github-img","date":"2022-07-29T09:26:52.000Z","updated":"2024-09-04T08:33:54.231Z","comments":true,"path":"2022/07/29/github/github-img/","link":"","permalink":"http://example.com/2022/07/29/github/github-img/","excerpt":"","text":"建立图床必须具备什么条件 首先你需要一个github账号，如果没有的话，请先注册。github官网地址 github.comPicGo下载地址 PicGo 一个github账号 一个公开的仓库 PicGo 上传图片 Typora 上传图片 一、新建仓库1.1 创建一个新仓库，用于存放图片。填写仓库名称和描述，且仓库必须是public的，否则存储的图片不能正常访问。 1.2 生成一个token，用于picGo访问github选择左侧菜单的Developer settings 之后选择左侧Personal access tokens，再点击Generate new token 填写Note，勾选repo.注意，生成的token只会在这里显示一次，所以记得单独保存下来哦。至此，Github的配置完成。 二、下载picGo，并进行配置2.1 下载访问picGo下载地址，选择 picGo-Setup-XXX.exe下载软件安装包即可。 如果安装成功，picGo不能正常使用，则可以用兼容模式启动,或者重启电脑。【此问题因电脑而异,重启电脑能解决百分之九十九的问题。】 2.2 配置仓库名：[github用户名]&#x2F;[第一步新建的仓库名称] 分支：默认master，从2020.10.01开始，github的默认分支名变更为main 设定token：第一步创建的token 指定存储路径：可填可不填，如果填写了，图片就会存储在img文件夹下 设定自定义域名： https://cdn.jsdelivr.net/gh/[github用户名]/[仓库名]@main,注意，此处的分支一定要填写@main，否则默认使用master分支。而现在github创建的默认分支名为main，如果不指定，则会出现图片不能上传的情况。我的是: https://cdn.jsdelivr.net/gh/txw1314/blog-img@main 2.3 插件安装点击插件设置右边的图标，进入插件网页，选择表格中的插件名称复制到input输入框,选择插件安装，可显示更多内容 至此，github+picGo的配置完成，可以在上传区进行图片上传了。 补充几点 原本github的自定义域名应该是： https://raw.githubusercontent.com/[username]/[仓库名]但是使用这种方式访问图片巨慢，所以建议使用jsdelivr作为cdn加速。改变域名即可，不需要任何其他配置。https://cdn.jsdelivr.net/gh/txw1314/blog-img@main 配置完成，可能出现不能上传的情况，请大家耐心检查，也许某一步的配置出现了问题，实在不行就重启电脑，毕竟重启电脑能解决99%的问题。 不止可以用github作为图床，还可以使用国内的码云(gitee)。当然也有收费的七牛、阿里云等等。在安装插件之后会有诸多选项。 三、上传图片上面配置完成，下面我们就可以上传图片了。 3.1 上传图片 3.2 上传图片完成 picGo监听端口设置 选择“PicGo设置”–&gt;“设置server” 如果监听端口不是36677，则需要修改为36677。否则会出现picGo能正常上传 图片，而typora上传图片失败的情况。如果picGO不能正常上传图片，建议重启电脑，我就是重启了之后就能正常上传图片了，只是图片不会显示缩略图 四 、使用Typora上传图片4.1 点击Typora文件—偏好设置如下图所示，选择图像，勾选右侧选项，上传服务，选择picgo路径，即可配置完成 4.2 我们也可以点击验证图片上传选项试一下 4.3 验证成功 4.4 我的验证失败了，虽然失败了，但是不影响我上传图片，嗯，问题不大，哈哈哈 然后就是在Typora复制文件图片，右键上传图片，稍等一下就会自动完成 tip: 在Typora粘贴图片的时候，个人建议使用Snipaste这个软件，非常方便！","categories":[{"name":"github","slug":"github","permalink":"http://example.com/categories/github/"}],"tags":[{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"picgo","slug":"picgo","permalink":"http://example.com/tags/picgo/"},{"name":"typora","slug":"typora","permalink":"http://example.com/tags/typora/"}]},{"title":"fariy-001","slug":"fairy/fairy-001","date":"2022-07-28T12:18:46.000Z","updated":"2024-09-03T07:42:24.933Z","comments":true,"path":"2022/07/28/fairy/fairy-001/","link":"","permalink":"http://example.com/2022/07/28/fairy/fairy-001/","excerpt":"","text":"#l_main { width: calc(100% - 1 * 0px); padding-left: 0px; float: left; -webkit-box-ordinal-group: 2; -moz-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2; } #l_side { display: none; } #post-body { display:flex; flex-wrap: wrap; } #post-body p { width: 48%; margin: 5px; } 壁纸","categories":[{"name":"壁纸","slug":"壁纸","permalink":"http://example.com/categories/%E5%A3%81%E7%BA%B8/"}],"tags":[{"name":"fariy","slug":"fariy","permalink":"http://example.com/tags/fariy/"}]},{"title":"Hexo之博客的安装与部署-01","slug":"hexo/Hexo之博客的安装与部署-01","date":"2022-07-28T11:14:42.000Z","updated":"2024-09-03T07:42:24.933Z","comments":true,"path":"2022/07/28/hexo/Hexo之博客的安装与部署-01/","link":"","permalink":"http://example.com/2022/07/28/hexo/Hexo%E4%B9%8B%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2-01/","excerpt":"","text":"一. 软件环境Git Node.js Clash for Windows(任意加速器，保证能连接到Github) 1.1 Git官网我们会将搭建好的Hexo上传到Github，所以需要Git命令行支持。 Git官网页面根据系统选择64/32位 1.2 Node.js选择下载LTS版本 如果你的网络无法进行下载，请访问以下链接进行下载： Git-密码0625-来自上杉九月的网盘分享https://cloud.sakurasep.club/s/YdiE Node.js-密码0625-来自上杉九月的网盘分享https://cloud.sakurasep.club/s/jdHB 1.3 检查安装是否成功打开cmd命令行，输入node -v后显示下图所示，即为安装成功 显示版本号 在电脑的任意目录点击右键，能够显示Git Bash Here使用这个功能可以更方便的在当前目录启动命令行，当然你也可以使用cmd的cd命令到当前目录 右键菜单出现选项 二. 博客本地化部署2.1 更改npm为cnpm源国内某些网络环境访问npm会出现问题，建议使用taobao镜像源，能有效减少故障的发生 切换npm源 1npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm切换过程 使用cnpm -v后正常输出版本号，即为安装成功 显示版本号 2.2 安装hexo命令行-g是对全局安装hexo命令行 安装Hexo命令行 1cnpm install hexo-cli -g hexo-cli安装过程 2.3 Hexo博客初始化选取一个想要安装Hexo的目录，路径中最好不要含有中文，后续会更好处理 Hexo初始化命令 1hexo init 初始化过程 此时文件夹内应有初始化文件，不过只要接下来能够成功运行，上述过程没有报错，就没问题。 hexo文件夹结构 如果初始化出现问题，即在运行hexo init的时候报错(通常是由于网络而出现问题) 如果出现网络问题导致无法下载，请访问以下链接获取基础包： Hexo_基础包文件-密码0625-来自上杉九月的网盘分享https://cloud.sakurasep.club/s/Nouy 2.4 运行博客在博客根目录右键打开Git Bash Here 输入以下指令 Hexo初始化命令 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s hexo clean 清除已经部署的网页静态文件 hexo g 编译当前博客 hexo s 启动本地服务器 本地部署过程 出现Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.，并且没有后续的警告语句，说明部署成功，在浏览器中输入localhost:4000查看部署效果。 运行成功 如果你的端口4000被占用，可以使用hexo s -p 端口号。然后访问http://localhost:端口号 以上，博客的最基本的本地化部署已经完成，接下来的内容是将博客部署到网络进行在线访问。 三. 博客部署到网络基本介绍一下目前不同部署方式的差别。 Github：微软旗下的开源代码托管平台，国内某些运营商可能无法访问，一般来说还是推荐部署在Github Pages，这也是我本人目前主要用的服务。 Gitee：虽然是国内的代码托管平台，访问速度可以保证，但是它的Pages页面需要手动更新，并且不能够绑定自定义的域名(如果你想和别的博主交换友链，最好还是要有一个域名。因为一般有域名的博客更有动力维护下去)。 Coding：部署方式很复杂，新版的Coding Pages貌似是和腾讯云挂钩，按量付费，感觉没必要了。 Vercel：是一个静态网页部署平台，好像访问速度要比Github稍微快一些，并且提供修改自定义域名。 云服务器：访问速度很大程度上取决于你的服务器的带宽，而且现在服务器的价格也不便宜，以后部署其他需要服务器的项目时再使用比较好。 3.1 部署到Github(推荐)全球最大同性社交平台 3.1.1 创建Github仓库注册完成Github账号，新建仓库用于保存上传博客代码。 Github账号注册时尽量不要使用国内邮箱，尤其是QQ邮箱 新建仓库 这里我已经存在该仓库，所以会爆红 Tips:试试新建一个仓库名为你Github用户名的仓库 按照图示修改好仓库名后，确保仓库为公开(Public)，其他设置按需更改，创建仓库。 3.1.2 获取与Github的连接在任意位置打开Git Bash Here，输入以下指令 建立与Github的连接 123git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot;ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 生成密钥 输入第三个命令后只需要连续按下三次回车，就会在C:\\Users\\用户名\\.ssh中生成密钥文件 打开id_rsa.pub，复制文件内容，添加到 添加SSH公钥添加SSH公钥 然后在Git Bash中输入以下命令测试是否连通Github 测试与Github的连接 1ssh -T git@github.com 成功连通 3.1.3 上传博客到Github首先在Git Bash中输入以下命令安装部署插件 安装hexo-deployer-git 1cnpm install hexo-deployer-git --save 安装成功 打开根目录下的_config.yml文件 deploy配置 config文件配置 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: 填入仓库连接 branch: master repo 可以复制此处的链接 复制仓库链接 填好后在Git Bash中输入下列命令部署到Github仓库 部署到Github 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d Github同理(此为部署到Gitee) 此时访问https://Github用户名.github.io即可访问 Github显示效果相同 3.1.4 绑定自定义域名你可以自行选择域名提供商，购买完域名后，在域名解析里设置以下解析记录 标准解析设置 解析记录简介主机记录：设置为@为泛解析，即访问域名为https://域名。如果想要设置为二级域名，请将主机记录设置为想要设置的名称，比如主机记录设置为hexo，即访问域名为https://hexo.域名记录类型：设置为CNAME，将域名解析到网址。因为Github建议将自定义域名以CNAME解析到Github用户名.github.io 然后在_config.yml中设置url为你解析的域名 url设置 最后再博客根目录/source下新建CNAME文件 注意，没有拓展名! 文件内容为自定义的域名 用于Github识别项目的自定义地址 3.2 部署到Gitee(备用方法)Gitee官网 3.2.1 创建Gitee仓库部署到Gitee与部署到Github的流程相差很小，看一个就行。 新建Gitee仓库 3.2.2 获取与Gitee的连接在任意位置打开Git Bash Here，输入以下指令 连接到Gitee 123git config --global user.name &quot;你的Gitee用户名&quot;git config --global user.email &quot;你的Gitee注册邮箱&quot;ssh-keygen -t rsa -C &quot;你的Gitee注册邮箱&quot; 获取SSH公钥 输入第三个命令后只需要连续按下三次回车，就会在C:\\Users\\用户名\\.ssh中生成密钥文件 打开id_rsa.pub，复制文件内容，添加到 添加SSH公钥 然后在Git Bash中输入以下命令测试是否连通Gitee 测试连接 1ssh -T git@gitee.com 连接成功 3.2.3 上传博客到Gitee首先在Git Bash中输入以下命令安装部署插件 安装hexo-deployer-git 1cnpm install hexo-deployer-git --save 安装过程 打开根目录下的_config.yml文件 Gitee配置 config文件配置 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: 填入仓库连接 branch: master repo 可以复制此处的链接 复制仓库链接 填好后在Git Bash中输入下列命令部署到Gitee仓库 部署到Gitee 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 上传成功 在仓库的服务-Gitee Pages进行手动部署 Github Pages会自动使用你仓库的代码进行部署，而Gitee需要你手动更新。 手动更新Pages 打开强制使用Https，更新部署 更新 等待部署结束后，访问Https://Gitee用户名.gitee.io查看部署结果 部署完成 3.3 部署到Vercel请在看过3.1部署到Github后再观看本部分教程。 官网 3.3.1 连接Github仓库连接仓库 项目名只能使用小写英文，无法使用大写英文，会报错 基本设置 稍等一段时间后，Vercel便部署完成了你的博客 部署完成 Vercel默认提供了域名，你也可以更改。到Settings-Domains中进行更改 更改域名 写在最后本篇文章基本讲述了Hexo博客的基本部署，包括了本地化部署测试和上传到Github，Gitee或是Vercel等平台，使用托管平台提供的Page服务进行远程访问。 本篇教程属于面向与小白的零基础教程系列，如果在安装过程中出现任何问题，你可以在评论区提问，你的提问也是我充实文章的助力！ 文章来源于上杉九月的博客(Hexo_01-博客的安装与部署 - 九月的生活 (sakurasep.site))","categories":[{"name":"Hexo系列","slug":"Hexo系列","permalink":"http://example.com/categories/Hexo%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]},{"title":"Hello World","slug":"study/hello-world","date":"2022-07-28T07:30:26.000Z","updated":"2024-09-04T11:26:38.234Z","comments":true,"path":"2022/07/28/study/hello-world/","link":"","permalink":"http://example.com/2022/07/28/study/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"个人学习","slug":"个人学习","permalink":"http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://example.com/tags/%E4%B8%AA%E4%BA%BA/"}]}],"categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"},{"name":"前端面试题","slug":"前端面试题","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"分类","slug":"分类","permalink":"http://example.com/categories/%E5%88%86%E7%B1%BB/"},{"name":"博客","slug":"博客","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"邮箱","slug":"邮箱","permalink":"http://example.com/categories/%E9%82%AE%E7%AE%B1/"},{"name":"win10","slug":"win10","permalink":"http://example.com/categories/win10/"},{"name":"github","slug":"github","permalink":"http://example.com/categories/github/"},{"name":"vscode","slug":"vscode","permalink":"http://example.com/categories/vscode/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"破解软件","slug":"破解软件","permalink":"http://example.com/categories/%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6/"},{"name":"合集","slug":"合集","permalink":"http://example.com/categories/%E5%90%88%E9%9B%86/"},{"name":"HelloWindows","slug":"HelloWindows","permalink":"http://example.com/categories/HelloWindows/"},{"name":"Electron","slug":"Electron","permalink":"http://example.com/categories/Electron/"},{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/categories/PicGo/"},{"name":"Hexo系列","slug":"Hexo系列","permalink":"http://example.com/categories/Hexo%E7%B3%BB%E5%88%97/"},{"name":"壁纸","slug":"壁纸","permalink":"http://example.com/categories/%E5%A3%81%E7%BA%B8/"},{"name":"个人学习","slug":"个人学习","permalink":"http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linktree","slug":"linktree","permalink":"http://example.com/tags/linktree/"},{"name":"跨域","slug":"跨域","permalink":"http://example.com/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"前端优化","slug":"前端优化","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"标签","slug":"标签","permalink":"http://example.com/tags/%E6%A0%87%E7%AD%BE/"},{"name":"nanoid","slug":"nanoid","permalink":"http://example.com/tags/nanoid/"},{"name":"WordPress","slug":"WordPress","permalink":"http://example.com/tags/WordPress/"},{"name":"nvm","slug":"nvm","permalink":"http://example.com/tags/nvm/"},{"name":"email","slug":"email","permalink":"http://example.com/tags/email/"},{"name":"vite","slug":"vite","permalink":"http://example.com/tags/vite/"},{"name":"gallery","slug":"gallery","permalink":"http://example.com/tags/gallery/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"vscode","slug":"vscode","permalink":"http://example.com/tags/vscode/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"},{"name":"phpMyAdmin","slug":"phpMyAdmin","permalink":"http://example.com/tags/phpMyAdmin/"},{"name":"WebStorm","slug":"WebStorm","permalink":"http://example.com/tags/WebStorm/"},{"name":"合集","slug":"合集","permalink":"http://example.com/tags/%E5%90%88%E9%9B%86/"},{"name":"HelloWindows","slug":"HelloWindows","permalink":"http://example.com/tags/HelloWindows/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"Electron","slug":"Electron","permalink":"http://example.com/tags/Electron/"},{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"评论系统","slug":"评论系统","permalink":"http://example.com/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"name":"twikoo","slug":"twikoo","permalink":"http://example.com/tags/twikoo/"},{"name":"busuanzi","slug":"busuanzi","permalink":"http://example.com/tags/busuanzi/"},{"name":"站点统计","slug":"站点统计","permalink":"http://example.com/tags/%E7%AB%99%E7%82%B9%E7%BB%9F%E8%AE%A1/"},{"name":"giscus","slug":"giscus","permalink":"http://example.com/tags/giscus/"},{"name":"typora","slug":"typora","permalink":"http://example.com/tags/typora/"},{"name":"picgo","slug":"picgo","permalink":"http://example.com/tags/picgo/"},{"name":"fariy","slug":"fariy","permalink":"http://example.com/tags/fariy/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"个人","slug":"个人","permalink":"http://example.com/tags/%E4%B8%AA%E4%BA%BA/"}]}